when you do npm run build (deploying React front end to production)
under the hood npm bundles the source code using webpack to create
the build directory for browsers to handle. 

the build defines an entry point for the app (usu index.js),
and includes all imports for that file (and the imports for the
imported files) 
--------------------
REACT webpack configuration from scratch:

1. Make A brand new directory:

Build (dir)
package.json
src (dir)
  -index.js (in src)
  -App.js (in src)
webpack.config.js //<-- this file defines webpack's functionality

package.json example starting content:

  {
      "name": "webpack-part7",
      "version": "0.0.1",
      "description": "practising webpack",
      "scripts": {},
      "license": "MIT"
  }

2. $npm install --save-dev webpack webpack-cli

3. Inside webpack.config.js:

  const path = require('path')
  const config = {
    entry:'./src/index.js',
    output: {
      path: path.resolve(__dirname, 'build'),
      filename: 'main.js'
      }
  }

  module.exports = config

^When executed, this code creates 'main.js' file added to
 the 'build' directory.

in the config object, entry defines the file that serves as 
starting point, output defines location where bundled code will
be stored, path.resolve is used to create an absolute path,
__dirname is a global variable in Node that stores path of 
current directory. So (__dirname, 'build') would be 'foo/build'


4. Add to package.json scripts: "build": "webpack --mode=development"

5. $npm install react react-dom

^required library for React

6. Inside index.js:
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'

ReactDOM.createRoot(document.getElementById('root')).render(<App />)

Note that components (ie: App.js) need to import React from 'react' also.

6. Add an index.html file to build dir to serve as 'main page' of app. 
 ^ 
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>React App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/javascript" src="./main.js"></script>
  </body>
</html>

7. Add a 'Loader' to the webpack to convert the JSX into regular JS
	^inside webpack.config file, add to config object:
      module: { 
        rules: [
          {
            test: /\.js$/,
            loader: 'babel-loader',
            options: {
              presets: ['@babel/preset-react'],
            },
          },
        ],
      },
^Loaders are defined in the rules array of module property. 
A loader has 3 parts: test, loader, and options:
test: Specifies that the loader is for files ending with js
loader: specifies what loader will process the files that match test property
options: specifies parameters for the loader, configuring its functionality

8. $npm install @babel/core babel-loader @babel/preset-react --save-dev

^the loader specified in step 7 and its required packages.

*NOTE: if you have issue where browser doesnt display code due to 
      async/await code, fix it by following instructions @:
	https://fullstackopen.com/en/part7/webpack#bundling-react
        (^ctl/f 'async/await' for the relevant section)


9. Transpiling the code:

Transpiling is to compile code from one language to another (ex: JSX to JS).

 In the webpack.config file, add to the options object (inside module):
  presets: ['@babel/preset-env', '@babel/preset-react']

$npm install @babel/preset-env --save-dev


10. Adding CSS ($touch src/index.css):

^import index.css inside index.js


11. Add loader for CSS:

$npm install style-loader css-loader --save-dev

^Inside rules array in webpack config file, add:

 { test: /\.css$/,
   use: ['style-loader', 'css-loader'],
 },

^style-loader loads css files, css-loader generates and injects a style
element containing all the styles of the app. 

*Note: with this setup, there's no need to import css into the index.html file,
just import it to index.js


12, Install webpack-dev-server:

webpack-dev-server lets us see the updated code without having to
create a new build and refresh the browser with every change.

$npm install --save-dev webpack-dev-server

in scripts object, add: "start": "webpack serve --mode=development"

in webpack.config, add to config object:
   devServer: {
     static: path.resolve(__dirname, 'build'),
     compress: true,
     port: 3000,
   }, 

13. Generating A Source Map

Source map makes it possible to map errors (so you can find out 
where an error is occuring in the app). This also enables use
of Chrome debugger

add to webpack.config in config object:
  devtool: 'source-map',

^restart the server after adding this

14. Minification 

To optimize the production build, in the "scripts" object in package:

"build": :"webpack --mode=production"

^(in an earlier step it was in development mode, setting it to 
  production mode automatically minifies it from webpack v4 onwards)

14. Adding a backend (start with installing axios & making db.json file)

To retrieve a backend server without hardcoding it, first change
the config inside webpack.config into a function:

^ const config = (env, argv) => {
    return {
      entry:'./src/index.js',
      output: {
        //...
       }, 
      devServer: {
        //...
      },
      devtool: 'source-map',
      module: {
      // ....
      },
      plguins: [
        //...
        ],
     }
   }

^Now, the function returns the config object. The second parameter, argv, 
can be used to access the mode that is defined in the npm script.

^make the following changes to webpack config file:

14-1. const webpack = require('webpack') //at top of file

14-2. //inside config function, before return object:

 const backend_url = argv.mode === 'production' 
       ? 'https://urltodatabase'
       : 'http://localhost:3001/foo'
					
14-3. //inside returned object
   plugins: [
     new webpack.DefinePlugin({
       BACKEND_URL: JSON.stringify(backend_url)
     })
    ]																																													

^Now, BACKEND_URL can be used in App file to read the server url.
^ex: axios.get(BACKEND_URL).then(res => setFoo(res.data))
Note: to inspect the bundled version of app locally, run 
$npx static-server in build dir, available default at localhost 9080.


15. Polyfill (Internet Explorer combatibility)

Axios doesn't work with IE (because promises), a polyfill is code 
that adds missing functionality to older browsers. 

Add to code (I think in index.js?):
  import PromisePolyfill from 'promise-polyfill'
  if (!window.Promise) {
    window.Promise = PromisePolyfill
  }





