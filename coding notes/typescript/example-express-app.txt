note: ts-node is not recommended beyond getting started, instead
      use the compiler (tsc) that comes with typescript package.

Getting started:

1. $npm init
2. $npm install typescript --save-dev
3. add a tsc command to package.json script:
  "tsc": "tsc"
4. $npm run tsc -- --init //initializes tsconfig file

5. A good starting tsconfig state:

{
  "compilerOptions": {
    "target": "ES6",
    "outDir": "./build/",
    "module": "commonjs",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "esModuleInterop": true
  }
}

^see config cheatsheet file in this dir for explanations


6. npm install express
7. $npm install --save-dev eslint @types/express 
    @typescript-eslint/eslint-plugin
    @typescript-eslint/parser

8. create .eslintrc
^example:
  {
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:@typescript-eslint/recommended-requiring-type-checking"
  ],
  "plugins": ["@typescript-eslint"],
  "env": {
    "browser": true,
    "es6": true,
    "node": true
  },
  "rules": {
    "@typescript-eslint/semi": ["error"],
    "@typescript-eslint/explicit-function-return-type": "off",
    "@typescript-eslint/explicit-module-boundary-types": "off",
    "@typescript-eslint/restrict-template-expressions": "off",
    "@typescript-eslint/restrict-plus-operands": "off",
    "@typescript-eslint/no-unsafe-member-access": "off",
    "@typescript-eslint/no-unused-vars": [
      "error",
      { "argsIgnorePattern": "^_" }
    ],
    "no-case-declarations": "off"
  },
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "project": "./tsconfig.json"
  }
}

^ 8.5. If using prettier:
  $npm install --save-dev eslint-config-prettier eslint-plugin-prettier
  and add "prettier" to plugins and extends arrays in .eslintrc.
  add .prettierrc.json file to dir
  ^ex: {
    "trailingComma": "es5",
    "tabWidth": 2,
    "semi": true,
    "singleQuote": true
    }


9. $npm install --save-dev ts-node-dev //for dev environment server updating

10. In package.json scripts:
  "dev": "ts-node-dev index.ts",
  "lint": "eslint --ext .ts ."

11. Create index.ts and get started!

^ex starting file:

import express from 'express';
const app = express();
app.use(express.json());

const PORT = 3000;

app.get('/ping', (_req, res) => {
  console.log('someone pinged here');
  res.send('pong');
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

12. Create a production build:
 $npm run tsc //works because outdir is defined in tsconfig file

13. Create .eslintignore and add build dir to it

14. Add script to run app in production mode:
   "start": "node build/index.js"

15. $npm install cors
    ^import cors in index.ts, then have app.use(cors())

------------
A standard way to handle external data is to 
seperate files for routers and for data handling.

<<IMPORTANT SIDENOTE>>: If using json data, add the following to tsconfig:
"resolveJsonModule": true
^IMPORTANT: this causes .json files to take precendence over .ts files
when importing, so make *sure* they have *different file names*.


Create a routes dir with a file for each document(collection?)

  ^ex src/routes/diaries.ts:
 
    import express from 'express';
    const router = express.Router();

    router.get('/', (_req, res) => {
      res.send('Fetching all diaries!');
    });

    router.post('/', (_req, res) => {
      res.send('Saving a diary!');
     });

    export default router;
//^ in index.ts, you call app.use('/urlpath/', routerFile)
//  to specify the path for each route.
//Note: The functions should indicate the their return types, which
       is done after creating types.ts (ex below)

^After creating routes, create a services dir in src/ and create a 
fooService module for 
handling data manipulation instead of mixing it in with
the router code. 

  ^ex: 
   import diaryData from '../../data/diaries.json';

   const getEntries = () => {
     return diaryData;
   };

  const addDiary = () => {
    return null;
  };

  export default {
    getEntries,
    addDiary
  };

^then import the services in the routes file:
ex: router.get('/', (_req, res) => {
  res.send(diaryService.getEntries());
--------------------------------

types.ts:

its good to create a types.ts file in src/ to define all
the types/interfaces in the project.

ex: export type Grade = 'F' || 'D' || 'C' || 'B' || 'A';
    export interface ReportCard { foo: number; bar?: Grade; }

//the ? after bar denotes an optional field

^then you can import { Grade, ReportCard } from '../types' 
 and use them to declare types of variables (ex: const foo: Array<Grade>.

If you run into an issue where the compiler's inferred type clashes with the
assigned type, the way to fix it is doing a type assertion (ONLY IF YOU 
ARE 100% SURE YOU KNOW WHAT YOU ARE DOING) 

   ^ const foo: Array<Bar> = barData as Array<Bar>;
 
   ^you assert that barData is Array<Bar> this should only be done if
   there is no other way forward, since it can cause runtime errors
    if a mistake is made.

^a possible alternative solution is to paste the data 
from the json file into a ts file and then 
export it after assigning it to a type:

 ^ex: import { BarData } from '../src/types';
   
  const barData: Array<BarData> = [
   { //copy pasted json }
];

export default barData

------------------
Utility Types:

A utility type can be used to construct a completely new type,
or to inform a function what it should return on runtime.

Utility types can also be used just like regular types. An
example utility type is Pick. 

Pick lets you choose which fields of a type can be used.

^ex: 
     const getNonSensitiveData = 
     (): Array<Pick<UserData, 'name' | 'username'>> => {
       // ...
      }

alternate syntax: 
   const getNonSensitiveData = 
   (): Pick<UserData, 'name' | 'username'>[] => {
     //...
   }

^This tells the compiler to return an Array of type UserData containing
 only the specified fields 'name' and 'username'. 

Omit is another utility type that omits the given field(s)

^ex: const getNonSensitiveData = (): Omit<UserData, 'password'>[] => {
      //....
     }
You can also use utility types in type declarations:

^ex export type NonSensitiveUserData = Omit<UserData, 'password'>;


 IMPORTANT: TS doesn't automatically modify the data, only its type.
            Therefore, You need to properly handle the data in the service
	    before sending it to the user:

//services/foo.ts:
   import users from '../../data/userData.ts'
   import {NonSensitiveUserData, UserData } from '../types'
  //other functions...

  const getNonSensitiveUserData = (): NonSensitiveUserData[] => {
    return users.map(({ name, username })) => ({
      name, username}));
    };

^Filter the users data so that only the desired fields are returned.

-------------------------
GETing a single resource:

//in the services file with DiaryEntry being imported from types.ts:
  //funciton to find an object by its ID field:
  const findById = (id: number): DiaryEntry | undefined => {
    const entry = diaries.find(d => d.id === id);
    return entry;
  }
 //add findById to exports

^IMPORTANT: Need to consider what the return value would be if 
            diaries.find() doesnt find a match, therefore the functions
            return type is DiaryEntry | undefined


^Then import the service method into the router file:
//imports & other routes... 

router.get('/:id', (req, res) => {
  const diary = diaryService.findById(Number(req.params.id));

  if (diary) {
    res.send(diary);
  } else {
    res.sendStatus(404);
  }
});

-----------------------------
POST requests:

1. Create a type for objects before they're assigned an ID
   (as they appear in the req.body of a post request):

  ^ex in types.ts: 
   export type NewDiaryEntry = Omit<DiaryEntry, 'id'>;

2. create service method for adding the request to array of existing objects
  
^ex in services/diaryServices.ts:
  const addDiary = ( entry: NewDiaryEntry ): DiaryEntry => {
  const newDiaryEntry = {
    id: Math.max(...diaries.map(d => d.id)) + 1,
    ...entry
  };

  diaries.push(newDiaryEntry);
  return newDiaryEntry;
};

3. Add route:

^ex in /routes/diaries.ts:
  router.post('/', (req, res) => {
  const { date, weather, visibility, comment } = req.body;
  const newDiaryEntry = diaryService.addDiary({
    date,
    weather,
    visibility,
    comment,
  });
  res.json(newDiaryEntry); //make sure app.use(express.json()) is in index
})

************ Guarding against bad request types:


IMPORTANT: Accepting data requests from outside sources comes with type 
           uncertainty, one way to handle it is to create a function
           that receives req.body as a parameter, checks for its
	   fields and their types, and returns an object that is properly
	    typed or throws an error.
 
	^this function should(?) go in utils.ts file

***Type Guards:

Type guard functions are functions that return a boolean and a 
a 'predicate' type. The standard for predicate types are to name them is:
parameterName is Type (Type being the type you're trying to verify)

*String type guard:*

^ex: const isString = (text: unknown): text is string => {
       return typeof text === 'string' || text instanceof String;
 }

^this type guard function returns a boolean *and* the predicate 
 text is string. Note that both typeof and instanceof are used because
 typeof works with const x = 'primitive', and instanceof works with
 const y = newString('String object'). 

^(y would return object for typeof, and x would return false for instanceof)

^then call the type guard function in a parse function that takes the 
 request body:

 const parseComment = (comment: unkown): string => {
   if (!comment || !isString(comment)) {
     throw new Error('missing or invalid');
   }
   return comment;
  }  


*Date type guard:*

const isDate = (date: string): boolean => {
  return Boolean(Date.parse(date));
}; //not actually a type guard since date is type string which is checked in
   //isString guard

const parseDate = (date: unknown): string => {
  if (!date || !isString(date) || !isDate(date)) {
      throw new Error('Incorrect or missing date: ' + date);
  }
  return date;
};

*Custom Type Guards:*

When guarding a custom-made type (ex Weather type), need to make sure
the type guard is always in sync with the possible values allowed for the
type. To do this, change the custom type to an enum - this allows you to
check all the values without hardcoding them in the typeguard.

^ex in types.ts: 
 export enum Weather {
   Sunny = 'sunny',
   Rainy = 'rainy',
   Cloudy = 'cloudy',
   Stormy = 'stormy',
   Windy = 'windy',
  }

^now can create a type guard to check if String is an accepted value:
  typeguard in utils:

  const isWeather = (param: any): param is Weather => {
    return Object.values(Weather).includes(param);
  };

  const parseWeather = (weather: unknown): Weather => {
    if(!weather || isWeather(weather)) {
      throw new Error('Incorrect or missing weather'); 
    }
    return weather;
  };

  *IMPORTANT: ^In order for this to work. The raw data with the Weather field
             (currently an array of objects with string fields in data dir)
             must be converted to a DiaryEntry object using type assertion

   ^ex in /data/diaryData.ts:
       const data = [ 
                     {//...raw data } ]
       const diaryEntries: DiaryEntry[] = data.map(obj => {
         const object = toNewDiaryEntry(obj) as DiaryEntry; //*
         object.id = obj.id;
         return object;
        });

  	export default diaryEntries //instead of the raw data export objs

       //*toNewDiaryEntry is function imported from utils
   

More compact example of type guarding custom data type:

1. Change field type to an enum: 

//in types.ts:
export const enum Visibility {
  Great = 'great',
  Good = 'good',
  Ok = 'ok',
  Poor = 'poor',
}

2. Create type guard:

  //in src/utils.ts: note that eslint disables might be needed
  const isVisibility = (param: any): param is Visibility => {
    return Object.values(Visibility).includes(param);
  }

3. Create type parser:
  //in src/utils.ts:
  const parseVisibility = (visibility: unknown): Visibility => {
    if (!visibility || !isVisibility(visibility)){
      throw new Error('Incorrect or missing visibility:' + visibility)
    }
    return visibility
  };

***Once all type guards are done***

FInally, to ensure the POSTed object is properly typed, pass a function 
that receieves the Fields and parses each of them:

^//in src/utils.ts:
 
type Fields = { comment: unknown, date: unknown, weather: unknown,
                visibility: unknown }
//^this lets you perform operations on each field

const toNewDiaryEntry = (
{ comment, date, weather, visibility,}: Fields): NewDiaryEntry => 
  {
    const newEntry: NewDiaryEntry = {
      comment: parseComment(comment),
      date: parseDate(date),
      weather: parseWeather(weather),
      visibility: parseVisibility(visibility),
    };
    return newEntry;
  }
export default toNewDiaryEntry

^ A bit hard to read, but basically the args the function takes are
  a destructured Fields type, and the function returns a NewDiaryEntry type.
  It then creates a new NewDiaryEntry object, with each field using the 
  previously created parseField() functions (that each use the isFoo type
  guard functions). 


Note: instead of making a Fields type and destructuring it to pass args,
can also disable eslint no-explicit-any for line above the 
toNewDiaryEntry function definition. 




