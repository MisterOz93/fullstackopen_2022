(Refer to graphql-basics doc. for backend/server configuration)
----------------
It's possible to use axios to communicate with graphql server, but
not recommended. You can send HTTP POST requests to localhost:4000/graphql,
the query is a string set as value to key query:
^ex: { "query": "query { allPersons{ name } }" }

A better method is using Apollo client (though Relay is also usable)

-----------------------------
Setting up Apollo Client:

$npm install @apollo/client graphql //inside frontend dir

//basic index.js example:

//react imports

import { ApolloClient,
ApolloProvider, HttpLink, InMemoryCache, gql } from '@apollo/client'

const client = new ApolloClient({
  cache: new InMemoryCache(),
  link: new HttpLink({
    uri: 'http://localhost:4000'.
  }),
})

const query = gql` //<- backtick
  query {
    allPersons {
      name
      phone
      address {
        street
	city
      }
      id
    }
  }
`
client.query({ query }).then(response) => {console.log(response.data) })

ReactDOM.createRoot(document.getElementById('root')).render(
  <ApolloProvider client={client}>
    <App />
  </ApolloProvider>

^client object is used to communicate with a graphql server.
Every component of the app can access the client object by wrapping the
App component with ApolloProvider

--------------------------------
Making Queries w/ Apollo Client:

The useQuery hook is the most popular way to make queries.

//inside App.js:

import { gql, useQuery } from '@apollo/client'

const ALL_PERSONS = gql` //<- backtick
query {
  allPersons {
    name
    phone
    id
  }
}
`  //<-backtick

const App = () => {
  const result = useQuery(ALL_PERSONS)

  if (result.loading) {
    return <div>loading...</div>
  }

  return (
    <div>
      {result.data.allPersons.map(p => p.name).join(', ')}
    </div>
  )
}

export default App

^^useQuery() takes a gql query as parameter and makes the query, 
it returns an object with diff fields, like loading - which is true
until the response is received. Once response is received, it is found in
data field. 

----------------------------
Named Queries & variables:

graphql has variables to make queries dynamically based on the 
variable value.

To use variables, queries must be named

^ex:
  query findPersonByName($nameToSearch: String!) {
    findPerson(name: $nameToSearch) {
      name
      phone
    }
  }

^using that query in App.js:

const FIND_PERSON = gql` //<- backtick
  query findPersonByName($nameToSearch: String!) {
  findPerson(name: $nameToSearch) {
    name
    phone
  }
}
` //<-backtick

To make the query only if condition is met (ie user clicks button),
add a local useState hook to the component and use the 2nd parameter
object of useQuery to set variables and set condition to skip the query:

^ex:

const Persons =( { queryDataField } => {
  const [nameToSearch, setNameToSearch] = useState(null)
  const result = useQuery(FIND_PERSON, { 
    variables: { nameToSearch },
    skip: !nameToSearch, //true if nameToSearch is null and viceversa
  })

  if (nameToSearch && result.data) {
    return(
     <Person person={result.data.findPerson}
       onClose={() => setNameToSearch(null) /> //onClose being clickhandler
    )
  }
 /*else, return a map of queryDataField with a button that onClick
   sets nameToSearch, thus triggering a re-render and the if block */

----------------------------------------------------
Cache:

Apollo client saves query responses to a cache, to avoid
making duplicate queries to the server. 
----------------------------------------------------
Doing mutations:

const CREATE_PERSON = gql`
  mutation createPerson($name: String!, $phone: String) {
    addPerson(
      name: $name,
      phone: $phone
    ) {
      name
      phone
      id
     }
  }
  `

^note 	the parameters in createPerson are then used in the 
 addPerson mutation, and note the return value including the id
 created in the backend. 

const [ createPerson ] = useMutation(CREATE_PERSON)
//useState hooks for name/phone

//a submit handler:
	
  const submit = (event) => {
    event.preventDefault()
    createPerson({ variables: { name, phone } })
    setName('')
    setPhone('')
  }

^useMutation hook returns an array, the first element of it contains the 
function to cause the mutation.
^notice that the mutation is called with variables object as parameter.

IMPORTANT: The mutation doesn't automatically rerender the page, to fix that 
we need to update the cache by either:
A) add a { pollInterval: 2000 } parameter to the getAll query
 ^ex: //in app: const result = useQuery(ALL_PERSONS, {pollInterval: 2000})
or
B) const [ createPerson ] = useMutation(CREATE_PERSON, {
     refetchQueries: [ { query: ALL_PERSONS } ] 
   })

So either add a pollInterval to get all every 2 sec (almost instant but 
  pointless web traffic)
or add refetchQueries (not almost instant, but no pointless traffic)

^use refectQueries

You can also refetch multiple queries:
 const [ createPerson ] = useMutation(CREATE_PERSON, {
  refetchQueries: [{ query: ALL_PERSONS}, {query: OTHER_QUERY}, etc.]
  })

--------------------------
Mutation error handling:

If data is invalid (ex: using a duplicate value if backend requires unique),
it causes an error in browser, handle it with useMutation's onError option:

^ex: const [createPerson] = useMutation(CREATE_PERSON, {
       refetchQueries: [ {query:ALL_PERSONS } ],
       onError: (error) => {
         setError(error.graphQLErrors[0].message) //setError being useState
       }
    })

-------------------------
Using Update mutation:

export const EDIT_NUMBER = gql`
  mutation editNumber($name: String!, $phone: String!) {
    editNumber(name: $name, phone: $phone){
      name
      phone
      id
    }
  }
`
^same as the addPerson mutation, parameters that are then used in the
 editNumber call. 

used like:

  const [ editNumber ] = useMutation(EDIT_NUMBER)
  
  const submit = (event) => {
    event.preventDefault() 
    editNumber({ variables: { name, phone } })
    setName('')
    setPhone('')
  }


^Note: The update appears immediately if the resource being updated has a
      unique ID because the cache updates automatically. 

------------------------
Creating an error:

If the errorHandler doesn't register an error 
(ex: a mutation to update a resource that can't be found returns null)
, you can set an error by using the result property of useMutation and
then useEffect:

^ex:  const [changeNumber, result] = useMutation(EDIT_NUMBER) 

      useEffect(() => {
        if (result.data && result.data.editNumber === null){
	  setError('person not found')
	}
      }, [result.data])

^ex: 

