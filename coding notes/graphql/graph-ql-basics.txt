GraphQL is an alternative to REST - communication between web apps and server.

REST is resource based, ie every resource has an address which defines it, ex:
www.foo.com/users/12340 and operations to the resource are done wiht http 
requests

GraphQL is based on the browser code forming a query describing the data
it wants, and sends it to the API with http post. 

ALL GraphQL queries are sent to the same address as type POST. 

^ex:

   query FetchBlogsQuery {
     user(username: "bob") {
       followedUsers {
         blogs {
           comments {
             user {
               blogs {
                 title {
               }
             }
           }
         }
       }
     }
   }
 }

^This means: find a user with username of "bob" and find all
of bob's followedUsers, and all the followedUsers' blogs, and all
those blogs' comments, and the user of each comment, and
the blogs by each user, and the title of each blog. 

^The server response would be a JSON object like:

 { "data": {
    "followedUsers": [
      {
        "blogs": [
          {
            "comments": [
              {
                "user": {
                  "blogs": [
                    {
                      "title": "Goto considered harmful"
                    },
                    {
                      "title": "End to End Testing with Cypress is most enjoyable"
                    },
                    {
                      "title": "Navigating your transition to GraphQL"
                    },
                    {
                      "title": "From REST to GraphQL"
                    }
                  ]
                }
              }
            ]
          }
        ]
      }
    ]
  }
}
--------------------------------
Schemas/Queries

A schema describes the data sent between client and server. 

Ex Schema:

  type Person {
    name: String!
    phone: String
    street: String!
    city: String!
    id: ID!
  }

  type Query {
    personCount: Int!
    allPersons: [Person!]!
    findPerson(name: String!): Person
  }

^Person type determines that Persons have 5 fields, ! denotes required,
the ID property is a string, but must be unique

Query type defines what kind of queries can be made to the API; personCount
returns an integer, allPersons returns a list of Person type objects, and
findPerson is given a string parameter and returns a Person object. 

When calling a query that returns objects (like allPersons), the query must 
describe which fields of the object the query returns.

^ex: query {
       allPersons {
         name
         phone
      }
    }

^an ex response could be:

{
  "data": {
    "allPersons": [
      {
        "name": "Bob",
        "phone": "123-4565"
      },
      {
        "name": "Doug",
        "phone": null
      }
    ]
  }
}

For a query that requires a parameter (ie findPerson), its written like:

query {
  findPerson(name: "Bob") {
    phone
    city
    street
    id
  }
}

^ response would be:

{
  "data": {
    "findPerson": {
      "phone": "1234-3515",
      "city": "w/e",
      "street": "w/e",
      "id": "34A529jfsd"
    }
  } 
}

GraphQL is not a database, it can be saved to any kind of
DB or server it can access. 

--------------
Apollo Server

Apollo Server is the leading library for implementing a graphQL server. 

$npm install apollo-server graphql

Basic layout of index.js:

const { ApolloServer, gql } = require('apollo-server')

let persons = [
  {
    //person object
  },
  {
    //another person object
  },
]

const typeDefs = gql`  // <-notice the backtick
  type Person {
    name: String!
    phone: String
    street: String!
    city: String! 
    id: ID!
  }

  type Query {
    personCount: Int!
    allPersons: [Person!]!
    findPerson(name: String!): Person
  }
` // <- notice the backtick

const resolvers = {
  Query: {
    personCount: () => persons.length,
    allPersons: () => persons,
    findPerson: (root, args) =>
      persons.find(p => p.name === args.name)
  }
}

const server = new ApolloServer({
  typeDefs,
  resolvers,
})

server.listen().then(({ url }) => {
  console.log(`Server ready at ${url}`)
})


^^^The ApolloServer takes 2 parameters, first the GraphQL Schema
(typeDefs), and the resolvers, which define how queries are responded to.

Note that the Query object in resolvers has a field for every
query in the schema (personCount, allPersons, findPerson).

The server is started by running $node index.js, going to the address
(default lh 4000) lets you visit studio that lets you make queries to server.

 
Notice that findPerson has 2 parameters, (root, args), root does not
need to be defined if it is not needed. All resolvers functions
are given 4 parameters, but in JS they don't need to be defined
unless they are needed in the function.
----------------------------------------------------
Default resolvers:

GraphQL server must define a resolver for every single field of each
type in the schema. In the ex. above, Query's fields are given resolvers,
but Person isn't. In that case, Person's fields get default resolvers:

ex of default resolver: 

  Person: {
    name: (root) => root.name,
    phone: (root) => root.phone,
    id: (root) => root.id
   }

You can also define resolvers for some fields and leave others blank
for the default. 
ex: setting Person: { name: (root) => 'Bob' } would make every Person's
    name Bob, but would get the property of every other field. 


If the schema has a field that the object saved in the server doesn't, 
the default resolver won't be able to retrieve that field. 

^ex, Person object has name, phone, city, and street fields, but 
the Person schema has name, phone, and address fields, where address
is its own schema that has street and city fields. 

^ex: type Address { street: String! 
		    city: String!
                  }
     type Person {
       name: String!
       phone: String
       address: Address!
       id: ID!
     }

^but Person objects saved to server have street and city fields,
default resolver won't be able to query person.address since it 
doesn't exist.

To get the address field, you need to add a resolver for it
inside the Person resolver:

 const resolvers = {
  //Query:...
  
  Person: {
    address: (root) => {
      return {
        street: root.street,
        city: root.city
      }
    }
  }
}

^root is the person object saved to the server so person.address
in the JSON response is made up from calls to person.street and person.city.

-----------------------

Mutations:

A Mutation is a type (defined in schema) used to cause chnages (ex: adding
resource to the server).

Operations performed by Mutation are defined inside the Mutation like:

//inside schema:

 type Mutation {
   addPerson(
     name: String!
     phone: String
     street: String!
     city: String!
   ): Person
  } 

^the details of the Person are given as parameters to addPerson, and the
return value is denoted as type Person. 
^Note that ID is omitted, since its better to leave creating that to
the server.

Mutations Resolver:

const { v1: uuid } = require('uuid')

//.. schemas

const resolvers = {
  //...other resolvers
  Mutation: {
    addPerson: (root, args) => {
      const person = { ...args, id: uuid() }
      persons = persons.concat(person)
      return person
    }
  }
}

^the uuid library ensures the id field is given a unique id


Calling the Mutation:

ex using addPerson:

mutation {
  addPerson(
    name: "Bob"
    phone: "555-3455"
    street: "Sesame"
    city: "Foo"
  ) {
    name
    phone
    address{
      city
      street
    }
    id
  }
}

^the person is saved to the persons array as defined in the parameters
of addPerson, but the mutation's response is the object defined afterwards,
with the address field.
---------------------------------

Error Handling:	

 GraphQL can automatically handle some validation errors (ex: calling
 a mutation with parameters that don't match the schema)

 But some errors have to be added manually for Apollo Server's Error 
 handling mechanism.

ex: stopping the creation of a resource with a duplicate name value.

^ const { UserInputError, //other imports } = require('apollo-server')

// ...schema and stuff

const resolvers = {
  //... other resolvers
  Mutation: {
    addPerson: (root, args) => {
      if (persons.find(p => p.name === args.name)) {
        throw new UserInputError('Name must be unique',{
          invalidArgs: args.name
      })    
    }

  //..rest of addPerson mutation
  }
}

^import the error type, then throw it in the mutation if the condition
is met. 

-------------------------------------------
Enum:

Enumerables let you filter queries using type YesNo. 

ex:

query {
  allPersons(phone: YES) {
    name
    phone
  }
}

^ once set up, this calls allPersons who have a phone number.

The schema for implementing enum is:

enum YesNo {
  YES
  NO
}

type Query {
  allPersons(phone: YesNo): [Person!]!
  //other resolver types
}


^The resolver for allPersons changes to:

const resolvers = {
  Query: {
    //other resolvers
    allPersons: (root, args) => {
     if (!args.phone) {
       return persons
     }
      const byPhone = (person) => {
        args.phone === 'YES' ? person.phone : !person.phone
      return persons.filter(byPhone)
      },
  }
}
^ So if a query is made to allPersons without a phone arg, persons
  is returned. else, a filtered version is returned depending on if
  allPersons(phone: YES) or allPersons(phone: NO) is passed. 

--------------------------------------
Changing data

The mutation for update is straightforward:
//inside schema:
type Mutation {
  addPerson( //...)
  editNumber(
    name: String!
    phone: String!
  ): Person

^as usual, schema just defines the parameters and the return types.

The resolver:

Mutation: {
  // ...addPerson
  editNumber:(root, args) => {
    const person = persons.find(p => p.name === args.name)
    if (!person) { return null }
    const updatedPerson = {...person, phone: args.phone }
    persons = persons.map(p => p.name === args.name ? updatedPerson : p)
    return updatedPerson
  }
}
^note that while the persons array is updated, its the updated Person that
gets returned, just like a POST request. 

-----------------------------------
Multiple queries:

In GraphQL, can combine multiple fields of type Query, 

ex: 

 query {
  personCount
  allPersons {
     name
   }
 }

^this query returns both the number of people and the names of all people

^the return value is:

{
  "data": {
    "personCount": 3, 
    "allPersons": [
      {
        "name": "Foo McBobFace"
      },
      {
	"name": "Ba Bar"
      }
    ]
  }
}


You can also use the same query multiple times, but must give
the queries diff names.

^ex:
  query {
    havePhone: allPersons(phone: YES) { name }
    phoneless: allPersons(phone: NO) { name }
 }

^the response is:

{
  "data": {
    "havePhone": [
      {
        "name": "Arto Hellas"
      },
      {
        "name": "Matti Luukkainen"
      }
    ],
    "phoneless": [
      {
        "name": "Venla Ruuska"
      }
    ]
  }
}
