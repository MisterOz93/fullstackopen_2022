1. $npm install mongoose (backend)

2. make a models dir and a schema (ex: person.js):
	const mongoose = require('mongoose')
        const schema = new mongoose.Schema({
          name: {
            type: String,
            required: true,
            minlength: 5
            },
         //etc
         })
       module.exports = mongoose.model('Person', schema)

^required is redundant with graphQl, but good to include anyways

3. inside index.js //refer to graphql basics for other parts of file

const { ApolloServer, UserInputError, gql } = require('apollo-server')
const mongoose = require('mongoose')
const Person = require('./models/person')

const { MONGODB_URI } = require('./utils/config') //config uses dotenv.config()


console.log('connecting to', MONGODB_URI)

mongoose.connect(MONGODB_URI)	
  .then(() => {
    console.log('connected to MongoDB')
  })
  .catch((error) => {
    console.log('error connection to MongoDB:', error.message)
  })

const typeDefs = gql`
  ...
`

const resolvers = {
  Query: {
    personCount: async () => Person.collection.countDocuments(),
    allPersons: async (root, args) => {
      // filters missing
      return Person.find({})
    },
    findPerson: async (root, args) => Person.findOne({ name: args.name }),
  },
  Person: {
    address: (root) => {
      return {
        street: root.street,
        city: root.city,
      }
    },
  },
  Mutation: {
    addPerson: async (root, args) => {
      const person = new Person({ ...args })
      return person.save()
    },
    editNumber: async (root, args) => {
      const person = await Person.findOne({ name: args.name })
      person.phone = args.phone
      return person.save()
    },
  },
}

const server = new ApolloServer({
  typeDefs,
  resolvers,
})

server.listen().then(({ url }) => {
  console.log(`Server ready at ${url}`)
})

*********
^the main changes are about getting the Persons from MongoDB instead of 
a hardcoded array. 
ex: allPersons resolver returns Person.find({})
Apollo server waits for the promise to resolve and then returns the
result

-------------------------
Using optional parameters:

ex: Find allPersons or allPersons with phone attribute if 
    optional paramter phone is passed as 'YES':
//in resolvers:
Query: {
  allPersons: async (root, args) => {
    if (!args.phone) {
      return Person.find({}) //returns all Persons if 
    }

    return Person.find({ phone: { $exists: args.phone === 'YES' } })
    //^ if args.phone === 'YES', it returns Persons whose phone is true,
    // else it returns Persons whose phone attribute is false
  },
}
----------------------------------
Validation:

To handle validation errors in the mongoose schema, add a try/catch
block to the save method for mutation.
^ex:

Mutation: {
  addPerson: async (root, args) => {
    const person new Person({ ...args })

    try {
      await person.save()
    } catch (error) {
      throw new UserInputError(error.message, {
        invalidArgs: args,
      })
    }
    return person
  }
}

---------------------------------
User management/login

Ex user schema:

const mongoose = require('mongoose')

const schema = new mongoose.Schema({
  username: {
    type: String,
    required: true,
    minlength: 3
  },
  friends: [
    {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Person'
    }
  ],
 })

module.exports = mongoose.model('User', schema)
****

logging in and identifying users is done with tokens:

gql schema:

//inside typeDefs:

  type User {
    username: String!
    friends: [Person!]!
    id: ID!
  } 

  type Token {
    value: String!
  }

  type Query {
  //..same as before
  me: User
  }

 type Mutation {
   //..same as before
   createUser(
     username: String!
   ): User
   login(
     username: String!
     password: String!
   ): Token
 }

resolvers for createUser/login mutations:

const jwt = require('jsonwebtoken')
const JWT_SECRET = 'NEED_SECRET_KEY'

Mutation: {
//..existing mutations

createUser: async(root, args) => {
  const user = new User({username: args.username})

  return user.save()
    .catch(error => {
      throw new UserInputError(error.message, {
        invalidArgs: args,
      })
    })
  }, 
  login: async (root, args) => {
    const user = await User.findOne({ username: args.username })

    if ( !user || args.password !== 'password') {
      throw new UserInputError("Wrong username or password")
    }

    const userForToken = {
      username: user.username,
      id: user._id,
    }

  return { value: jwt.sign(userForToken, JWT_SECRET) }
  },
}, 

^^ calling the mutations is done like:

mutation {
  createUser(
    username: "bob"
  ) {
     username
     id
    }
 }

mutation {
  login (
    username: "bob"
    password: "password"
  ) {
     value
    }
 }


^as defined in the mutation, the value that login returns is the 
token string. Like with REST, the token is added to GraphQL queries
using the Authorization header.
In Apollo Explorer, can set Headers on bottom tab, (remember to write
'bearer' sans quotes before pasting the token value)

For Apollo Server to use token authentication, need to pass a third
parameter to the ApolloServer constructor call:

^ex: 
  const server = new ApolloServer({
    typeDefs,
    resolvers,
    context: async ({ req }) => {
      const auth = req ? req.headers.authorization : null
      if (auth && auth.toLowerCase().startsWith('bearer ')) {
        const decodedToken = jwt.verify(
          auth.substring(7), JWT_SECRET
        )
        const currentUser = await User.findById(decodedToken.id).populate('friends')
        return { currentUser }
      }
    }
})


^the object returned by context is given to all resolves as their third
parameter (root, args, context). So you want it to contain things
that are shared by multiple resolvers, like user identification. 

So the resolver to 'me' (added to typeDef query above)
to find the current user is:
//in resolvers:
  Query: {
  //existing queries
    me: (root, args, context) => {
      return context.currentUser //undefined if no user logged in
    }
  }
------------------------------
Enforcing Authentication for mutations:

Resolver for addPerson mutation:
//in resolvers

Mutation: {
  addPerson: async (root, args, context) => {
    const person = new Person({ ...args })
    const currentUser = context.currentUser
    if (!currentUser) {
      throw new AuthenticationError("Not authenticated")
    }
    try {
      await person.save()
      currentUser.friends = currentUser.friends.concat(person)
      //^the user adding a person also adds them to their friend list
      await currentUser.save()
    } catch (error) {
      throw new UserInputError(error.message,{
        invalidArgs: args,
      })
    }
    return person
  },
//other mutations
}
 
Mutation for adding an existing user to another user's friendlist:

The type definition:
  //inside typeDefs:
  type Mutation {
   //other mutation defs
    addAsFriend(
      name: String!
    ): User
  }

The resolver:

 addAsFriend: async (root, args, context) => {
   const isFriend = (person) => context.currentUser.friends.map(f =>
     f,_id.toString()).includes(person._id.toString())
   //^helper function to check if given person is already in user's flist

   if (!context.currentUser) {
     throw new AuthenticationError('Authentication Error')
   }

   const person = await Person.findOne({ name: args.name })
   if (!isFriend(person)){
     context.currentUser.friends = context.currentUser.friends.concat(person)
   }

   await context.currentUser.save()
   return context.currentUser
  //better to destructure { currentUser } than context.currentUser

The query to get a user's friends list:

query {
  me {
    username
    friends{
      name
      phone
    }
  }
}

//start with connecting mongodb to app to finish exercise 8.13, see index.js
top of file
