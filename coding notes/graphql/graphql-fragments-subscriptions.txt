this continues from after user-login-basics file.


-------------------------------------------------
Fragments:

Fragments can be used in multiple queries to define
what to query, saving you from having to rewrite the
same stuff in different queries.

^ex:

fragment PersonDetails on Person {
  name
  phone
  address {
    street
    city
  }
}

^can then be used in queries like:

query {
  allPersons {
    ...PersonDetails
  }
}


*Fragments are NOT DEFINED IN SCHEMA, but in the client

Best way to use fragments is to define them once using 
a variable,

^Ex:

const PERSON_DETAILS = gql`
  fragment PersonDetails on Person {
    id
    name
    phone
    address {
      street
      city
   }
  }
`
and then place the variable in a query and mutation using ${}

^ex:

 export const FIND_PERSON = gql`
   query findPersonByName($nameToSearch: String!) {
     findPerson(name: $nameToSearch) {
       ...PersonDetails
     }
   }
   ${PERSON_DETAILS}
 `

------------------------------------

Subscriptions:

Subscriptions are a third operation type (the others being query and 
mutation).

Subscriptions let clients subscribe to updates about changes in the server.

Traditional interaction btwn browser and server is:
browser makes http request to server.

Subscriptions is the opposite - after an app makes a subscription, 
it listens to the server. When a change happens on the server, it sends
a notification to all of its subscribers. 


In order to set up subscriptions, need to do the following:

1. Replace Apollo Server with Apollo Server Express:

$npm install apollo-server-express apollo-server-core express 
@graphql-tools/schema

^all on one command (space btwn express and @graphql-tools/schema)


2. Set up index.js this way:

const { ApolloServer } = require('apollo-server-express')
const { ApolloServerPluginDrainHttpServer } = require('apollo-server-core')
const { makeExecutableSchema } = require('@graphql-tools/schema')
const express = require('express')
const http = require('http')

const jwt = require('jsonwebtoken')

const JWT_SECRET = 'NEED_HERE_A_SECRET_KEY'

const mongoose = require('mongoose')

const User = require('./models/user')

const typeDefs = require('./schema')
const resolvers = require('./resolvers')

const MONGODB_URI = 'mongodb+srv://databaseurlhere'

console.log('connecting to', MONGODB_URI)

mongoose
  .connect(MONGODB_URI)
  .then(() => {
    console.log('connected to MongoDB')
  })
  .catch((error) => {
    console.log('error connection to MongoDB:', error.message)
  })

// setup is now within a function
const start = async () => {
  const app = express()
  const httpServer = http.createServer(app)

  const schema = makeExecutableSchema({ typeDefs, resolvers })

  const server = new ApolloServer({
    schema,
    context: async ({ req }) => {
      const auth = req ? req.headers.authorization : null
      if (auth && auth.toLowerCase().startsWith('bearer ')) {
        const decodedToken = jwt.verify(auth.substring(7), JWT_SECRET)
        const currentUser = await User.findById(decodedToken.id).populate(
          'friends'
        )
        return { currentUser }
      }
    },
    plugins: [ApolloServerPluginDrainHttpServer({ httpServer })],
  })

  await server.start()

  server.applyMiddleware({
    app,
    path: '/',
  })

  const PORT = 4000

  httpServer.listen(PORT, () =>
    console.log(`Server is now running on http://localhost:${PORT}`)
  )
}
// call the function that does the setup and starts the server
start()

^end of index.js, main differences from before are the
imports and creating a start function i n which to
create and configure the server.


3. (After index.js setup) Add 2 packages needed for subscriptions:
 $npm install graphql-subscriptions ws graphql-ws

4. Make changes to index.js:

  const {execute, subscribe} = require('graphql')
  const { WebSocketServer } = require('ws')
  const { useServer } = require('graphql-ws/lib/use/ws')
  //...other imports and variables
  const start = async () => {
     const app = express()
     const httpServer = http.createServer(app)

     const schema = makeExecutableSchema( { typeDefs, resolvers })
     
     const wsServer = new WebSocketServer({
       server: httpServer, 
       path: '/',
      })
     const serverCleanup = useServer({ schema }, wsServer)

     const server = new ApolloServer({ 
      schema,
      context: //same as above
    },
    plugins: [
      ApolloServerPluginDrainHttpServer({ httpServer }),
      {
        async serverWillStart() {
          return {
            async drainServer() {
              await serverCleanup.dispose()
            },
          }
        },
      },
    ],
  })
 //server.start, applyMiddleware, port, httpServer.listen the same as above
start()

^main changes are imports, adding the wsServer, serverCleanup, and adding
to the plugins array. GraphQL uses the http protocol for queries and mutations,
and uses websockets for subscriptions.

5. Add type Subscription to schema's typeDefs: 
 ex:
  type Subscription {
    personAdded: Person!
  }

6. Set up resolvers file and add resolver for subscriptions:
  ex:
   const {PubSub} = require('graphql-subscriptions')
   const pubsub = new PubSub()
   //...other imports

   const resolvers = {
     //...query resolvers
     //inside addPerson mutation resolver:
     //after try/catch await person.save() add line:
         pubsub.publish('PERSON_ADDED', { personAdded: person })
       return person     
       },//end of addPerson resolver	
     }, //end of Mutations obj in resolvers
     Subscription: {
       personAdded: {
         subscribe: () => pubsub.asyncIterator('PERSON_ADDED')
       },
     },
   } 

^the personAdded resolver registers and saves info about all the clients
 that subscribe to it to an iterator object. The name 'PERSON_ADDED' is the
conventional name for the iterator object (the subscription name in caps)

the line added to addPerson mutation publishes a notification to all
subscribers with the publish method - sending a WebSocket message to
all clients registered in the iterator object. (In apolloclient, check
connection settings to make sure subscriptions are set if not working)

---------------------------------------------
Subscriptions on the client (Front end)

To get subscriptions working on front end, need to 
add packages and reconfigure index.js:

1. $npm install @apollo/cient graphql-ws

2.index.js becomes:
//import React
  import { ApolloClient, ApolloProvider, HttpLink, InMemoryCache,
           split } from '@apollo/client'
  import {setContext} from '@apollo/client/link/context'
  import { getMainDefinition } from '@apollo/client/utilities'
  import { GraphQLWsLink } from '@apollo/client/link/subscriptions'
  import { createClient } from 'graphql-ws'

  const authLink = setContext((_, { headers }) => {
	//...unchanged from before, see prev. front end or user admin doc
  
  const httpLink = new HttpLink({
    uri: 'http://localhost:4000',
  })
  
  const wsLink = new GraphQLWsLink(
    createClient({
      url: 'ws://localhost:4000',
    })
  )

  const splitLink = split( ({ query }) => {
    const definition = getMainDefinition(query)
      return(
        definition.kind === 'OperationDefinition' &&
        definition.operation === 'subscription'
      )
    },
    wsLink,
    authLink.concat(httpLink)
  )

  const client = new ApolloClient({
    cache: new InMemoryCache(),
    link: splitLink
  })

  ReactDOM.createRoot(//...yada yada) 

^main differences are the wsLink, which is then given
along with the auth/http concat link to the splitLink.


3. in the app, use the useSubscription hook for subscriptions:

^ex (in queries.js):
  export const PERSON_ADDED = gql`
    subscription {
      personAdded {
        ...PersonDetails //see Fragment section
      }
    }

  ${Person_DETAILS}
`
//in app.js:
  import {useQuery, useMutation, useSubscription, useApolloClient} 
  from '@apollo/client'}

  const App = () => {
    //...see prev. front end file for app to this point
    
    useSubscription(PERSON_ADDED, {
      onSubscriptionData: ({ subscriptionData }) => {
	const addedPerson = subscriptionData.data.personAdded
        client.cache.updateQuery({ query: ALL_PERSONS }, ({ allPersons }) =>
	  {
	    return {
              allPersons: allPersons.concat(addedPerson),
      }
    })
  }
})

^
The callback defined in the onSubscriptionData field is called when a
new person is added and is given the details of the new person as parameters.

The updateQuery method is used to immediately update the Apollo cache to
immediately render to the screen.

4. Incase another component is also adding the data to the cache,
you can prevent a double-render by adding a helper function to app.js:

^ex: 

 export const updateCache = (cache, query, addedPerson) => {
  //start w/ a nested helper function to ensure person added once  
  const uniqueByName = (a) => {
     let seen = new Set()
     return a.filter((item) => {
       return seen.has(item.name) ? false : seen.add(item.name)
     })
  }//end of nested function

  cache.updateQuery(query, ({ allPersons }) => {
    return {
      allPersons: uniqueByName(allPersons.concat(addedPerson)
    }
  })
} //end of updateCache function

const App = () => {
 //...

 useSubscription(PERSON_ADDED, {
   onSubscriptionData: ({ subscriptionData, client }) => {
     const addedPerson = subscriptionData.data.personAdded
     updateCache(client.cache, {query: ALL_PERSONS }, addedPerson)
   },
 })

^then import { updateCache } to the component(s) that also add the data
to the cache, and call the updateCache function in the update: field of
useMutation

^ex in PersonForm component:  
   const [createPerson] = useMutation(CREATE_PERSON, {
     onError: (error) => {//...},
     update: (cache, response) => {
       updateCache(cache, { query: ALL_PERSONS }, response.data.addPerson)
     }, 
   })

----------------------------------------------

n+1 problems

n+1 problems refer to queries with a "has many" relationship,
for example: you have Person objects that has a friendOf array of users who
have that person in their friend's list.

An n+1 query would first fetch all Persons(1), and then for each 
Person(n) it would fetch the list of Users to find the Person's friends.

^example:

query {
  allPersons {
    name 
    friendOf {
      username
    }
  }
}

This pings the server once for the allPersons resolver, and then 
pings the server n times for the friendOf resolver, (n being the number of
Persons returned by allPersons).

The solution depends on the situation. Usually, you want to use a 
join query instead of multiple separate queries. 

^ex: In the Person's mongoose schema, create a friendsOf field thats
joined to User objects:
  //in models/persons.js schema:
  friendOf: [ 
    {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    }
  ],

^then, in the allPersons resolver, return 
Person.find({}).populate('friendOf'), which eliminates the need of a
seperate resolver for friendOf. 

GraphQL DataLoader library is also a good solution for n+1 problems,

see more @ 
https://www.robinwieruch.de/graphql-apollo-server-tutorial/#graphql-server-data-loader-caching-batching

