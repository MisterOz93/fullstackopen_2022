Note: These notes follow the steps in the graphql-with-mongodb file.


**These examples assume a backend with User objects and token authorization 
set in the backend (see graphql with mongodb file)**


To handle login authorization in frontend:

1. In App, add const [token, setToken] = useState(null)
2. if (!token) return a LoginForm component:
  ^ex: if (!token) {
         return (
           <div>
	     <Notification errorMessage={errorMessage}/> //custom component
	     <h2> Login </h2>
	     <LoginForm setToken={setToken}
               setError={notify} /> //notify is custom function to setErrormsg
	     />
	  </div>
        )
      }

3. Define a mutation for logging in
//inside queries.js:

export const LOGIN = gql`
  mutation login($username: String!, $password: String!){
    login(username: $username, password: $password) {
      value //i assume the token value?
    }
  }
` // <- backtick closes

4. Create the login form component:

^example: 

import { useState, useEffect } from 'react'
import { useMutation } from '@apollo/client'
import { LOGIN } from '../queries'

const LoginForm = ({ setError, setToken }) => {
  const [username, setUsername] = useState('')
  const [password, setPassword] = useState('')

  const [ login, result ] = useMutation(LOGIN, {
    onError: (error) => {
      setError(error.graphQLErrors[0].message)
    }
  })

  useEffect(() => {
    if ( result.data ) {
      const token = result.data.login.value
      setToken(token)
      localStorage.setItem('phonenumbers-user-token', token)
    }
  }, [result.data]) // eslint-disable-line

  const submit = async (event) => {
    event.preventDefault()

    login({ variables: { username, password } })
  }

  return (
    <div>
      <form onSubmit={submit}>
        <div>
          username <input
            value={username}
            onChange={({ target }) => setUsername(target.value)}
          />
        </div>
        <div>
          password <input
            type='password'
            value={password}
            onChange={({ target }) => setPassword(target.value)}
          />
        </div>
        <button type='submit'>login</button>
      </form>
    </div>
  )
}

export default LoginForm

^Note how the useEffect only triggers if result.data,
and not only setToken but also sets localStorage. 
(presumedly a logout function would remove item from localStorage)
Without useEffect there would be an infinite re-render loop

5. Add a logout button to App to set the token state to null,
   removes it from localStorage, and resets the Apollo client's cache.
Important to reset Apollo cache since it stores data that only 
logged in users should have access to. Clear cache with
client.resetStore()

^ex:

 //in App:
 //at beginning of app after useState and useQuery calls:
 const client = useApolloClient() //import with useMutation

 const logout = () => {
   setToken(null)
   localStorage.clear()
   client.resetStore()
   }
//... in return xtml:

 <>
 <button onClick={logout} /> LogOut </button>

-------------------------
Adding a token to a header:

If some backend operations require a token sent with the request, 
the ApolloClient object in index.js needs to be modified:

^ import { setContext } from '@apollo/client/link/context'

  const authLink = setContext((_, { headers }) => { //note the _, b4 headers
    const token = localStorage.getItem('value-given-to-localStorage')
    return {
      headers: {
        ...headers,
	authorization: token ? `bearer ${token}` : null,
      }
    }
  })

  const httpLink = new HttpLink({uri: 'http://localhost:4000})
  
  const client = new ApolloClient({
    cache: new InMemoryCache(),
    link: authLink.concat(httpLink)
  })

 //..then createRoot and render

^^^the link parameter of client defines how apollo connects to server, 
the httpLink is modified so that if there's a token in localStorage, 
its added to an authorization property of authLink's headers, 
and then authLink is set to the start of the client's link property. 

-----
A possibly better way to update the cache after mutations to render
instead of * refetchQueries: [ {query: MUTATION_NAME} ], * in the
object passed to 2nd parameter of useMutation, is to 
define an update callback for the mutation which is run
after the mutation:

^ex:
   const [ createPerson ] = useMutation(CREATE_PERSON, {
     onError: (error) => {
       setError(error.graphQLErrors[0].message)
     },
     update: (cache, response) => {
       cache.updateQuery({ query: ALL_PERSONS }, ({ allPersons }) => {
         return {
           allPersons: allPersons.concat(response.data.addPerson),
         }
       })

^the callback function (update) is given a reference to the cache and 
the data returned by the mutation (response). cache.updateQuery updates
the given query (ALL_PERSONS) by the function passed after it. 

When necessary, its possible to disable cache for the app or for single
queries by setting the fetchPolicy property (of useQuery) as no-cache. 

Be diligent with the cache. Old data in cache can cause hard-to-find bugs. 
keeping the cache up to date is very challenging. 

