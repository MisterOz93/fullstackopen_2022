 ----------Databases---------

Document Databases are categorized under the NoSQL umbrella term.
Mongo is a document db. 

Relational DB store data in separate tables defined by the programmer, a
single object may be soread across separate tables.

In a document DB, all info for a single object is stored in a single instance
of the db, eleminating the need for 'object relational mapping'.


documents are addressed in the db via unique key that represents that doc. 
(string or URL or path, typically). 

document db also allow API or query language to retrieve documents based on
content or metadata. 

-------MongoDB------

mongo stores data records as BSON (binary representation of JSON, containing
more types) documents, documents are gathered together in 
collections, A database stores one or more collection.

Collections are analogous to tables in relational databases.

MongoDB documents are composed of field and value pairs.
^ex: { 
	field1: value1,
	field2: value2,
	fieldN: valueN
	}
The value of a field can be any BSON data type as well as 
other documents, arrays, array of documents

Mongo uses dot notation to access elements of an array or 
to access field of an embedded document.
^ex: "arrayName.indexNumber"
    or "embeddedDocumentName.fieldName"
	^(ex: { name: {first: "Alan"} would be "name.first")
embedded document is essentially an object within the main object. 


-----MongoDB Atlas------

wait for the cluster/db to finish before proceeding. 

create a new database user (use different username/pw than your accnt)

^pw for this crud app is db123, read/write to any db. 

After setting user and network access, connect to the DB using
'connect your application'. This gives URI address to supply the
MongoDB client library once its added to the app. 
^To rename the db, change the part between mongodb.net and ? in
the uri. 


DB current state can be seen in browse Collections tab on Atlas website.

----------Mongoose-----
Mongoose is an 'object document mapper' makes saving JS objects
as Mongo documents easy. 
step 1: $npm install mongoose

----code preamble (in its own js file, update if this should go in index):

const mongoose = require('mongoose')

const password = process.argv[2] 
^//process.argv[2] is the 3rd command you put in terminal
^// ex: $node mongo.js pw <-- pw is argv[2]

const url = `...${password}...` //URI given by connecting db to your app.

mongoose.connect(url)

//***creating/saving objects to db***

const fooSchema = new mongoose.Schema({
   fieldName: Data type for fieldName,
   fieldName2: Data type for fieldName2,
   etc... 
  }) 

const Foo = mongoose.model('Foo', fooSchema);

//^ The schema tells mongoose how the foo objects are to 
    be stored in the DB. 
/* in the Foo model definition, the first parameter is the name of the
model (singular), convention is to name the collection of Foo as the 
plural when the schema refers to them in the singular. Models
act like constructor function. 

Document DBs (like Mongo) are schemaless, meaning db itself doesnt
care about the structure of the data, its possible to store
documents with completely different fields in same collection. 

The idea behind Mongoose is that data stored in the DB is given
a schema at the level of the application that defines the shape of the 
documents stored in any given collection.
*/

const foo = new Foo({
   fieldName: value,
   fieldName: value,
    etc...,
   }) 

^foo has all properties of the model, which includes built in things
like method for saving the object to the db. 

^ foo.save().then(result => {
   console.log('foo saved!')
   mongoose.connection.close() //DONT FORGET THIS!
  })

//^the event handler given to <then> gets called when the object
   is saved to the db. <result> is the result of the save operation

 //***fetching objects from db ***

Foo.find({}).then(result => { //parameter is an object expressing search conditions
   result.forEach(foo => {
 	console.log(foo)
 }) 
 mongoose.connection.close()
 }) 

^prints all Foo stored in the db. 

Make sure you close the connection inside the callback function(then), if you close 
it outside, the connection closes immediately after Foo.find is started.


------Adding MongoDB to backend------

add to index.js:

const mongoose = require('mongoose')

const url = <db url> //don't include password? instead

mongoose.connect(url)

const fooSchema = new mongoose.Schema({
   field: Type, 
   field: Type,
   ... 
   }) 

const Foo = mongoose.model('Foo', fooSchema)

//to fetch all Foo:

app.get('/api/fooList', (req, res) => {
  Foo.find({}).then(fooList => {
	response.json(fooList)
    })
  }) 

-----Formatting the objects returned by Mongoose---

fooSchema.set('toJSON, {
 transform: (document, returnedObject) => {
  returnedObject.id = returnedObject._id.toString();
  delete returnedObject._id
  delete returnedObject.__v
  }
 })

^This changes the fooSchema so that when any model of Foo produced by it
 gets data with JSON (ex: response.json), it creates an id field as a string that replaces the
_id field that's an object. And it removes the _id object and __v object
that mongoose(?) automatically creates.



----Extracting Mongoose code to its own module---

$mkdir models, then $touch foo.js (name of each object)

in foo.js:

const mongoose = require('mongoose')

const url = process.env.MONGODB_URI //see next section on dotenv

console.log(`connecting to ${url}`)

mongoose.connect(url).then(result => {
  console.log('connected to MongoDB')
  })
  .catch((error) => {
  console.log(`error connecting to MongoDB: ${error.message}`)

const fooSchema = new mongoose.Schema({
  field: Type,
  ...
 }) 

fooSchema.set('toJSON', {
 transform: (document, returnedObject) => {
  returnedObject.id = returnedObject._id.toString();
  delete returnedObject._id
  delete returnedObject.__v
  }
 })

module.exports = mongoose.model('Foo', fooSchema)

//users of the module only get access/visibiliy to the
//name and schema assigned to module.exports.

^^Then in index.js:

const Foo = require('./models/foo')
//^ this way Foo variable is assigned to same object the model defines.
//just like const Foo = mongoose.model('Foo', fooSchema) before.


----dotenv for process.env----

One (not best) way to define the value of an environment variable
is in the terminal when starting the app:
ex: $MONGODB_URI=address_here npm run dev

A better way is using the dotenv library

step 1: $npm install dotenv

step 2: create a .env file at the root of the project.
env variables are defined inside the file.
ex: MONGODB_URI=' insert url here'
PORT=3001 

step 3: WRITE .env TO GITIGNORE FILE RIGHT AWAY.

step 4: in index.js: 
	require('dotenv').config()

^DEFINE DOTENV BEFORE defining any modules that need its variables.

^can then refer to the env variables like:
const PORT = process.env.PORT


----Using DB in backend route handlers---

***to post a foo object:***

app.post('api/fooList', (req, res) => {
  const body = request.body
  if (body.importantField === undefined) {
 return response.status(400).json({error: 'importantField missing'})
}

  const foo = new Foo({  //constructor
    dataField: body.dataField
    datafield2: body.dataField2
    ...
 })

  foo.save().then(savedFoo => { //response sent in callback fnctn
  res.json(savedFoo)
  })
 }) 


***to fetch a single foo***:

app.get('api/fooList/:id', (req, res) => {
  Foo.findById(req.params.id).then(foo => {
    res.json(foo)
  })
 })

^If we try to fetch a note with an id that doesn't
match the mong oidentifier format (ex too many bytes)
, you get a CastError. (cast to ObjectId failed for value <the invalid id>...)

^In that case, its good to response.status(400).send({error" 'malformed id"}
in the catch block. 

When dealing with promises, its almost always good to add error/
exception handling. And not a bad idea to print the object 
causing exception to the console for debugging. 

ALWAYS KEEP EYE ON CONSOLE OUTPUT OF THE BACKEND. 


-----Moving error handling into middleware-----

putting all error handling in a single place is
useful if you want to report data related to errors
to an external error tracking system. 


----Express Error handlers-----

Error handlers in express are middleware defined
with 4 parameter function:

const errorHandler = (error, request, response, next) => {
console.error(error.message)

if (error.name === 'CastError) {
   return response.status(400).send({ error: 'malformatted id' }) 
 }
 next(error) //passes error to Express's default error handler. 
} 

app.use(errorHandler) //This has to be the last loaded middleware

^The execution order of middleware is the same as the order they are 
loaded into express w/ app.use(). 

Middleware for handling unsupported routes should be next to last ahead of 
error handling. 

^handling unsupported routes with a 404 will trigger on all requests, so
it has to be used only after defining proper routes. No routes or middleware
(besides error handling) will be called after unknown endpoint middleware.


Personal observation: Even if other middleware is app.use()'d after the route
and before the error handler, the error still goes to the errorHandler as
long as the (error) parameter is given to next(error). 

------------Deleting from DB --------

app.delete('api/fooList:id', (request, response, next) => {
 Foo.findByIdAndRemove(request.params.id).then( result => {
	response.status(204).end()
 })
  .catch(error => next(error)) //assuming there's error handler middleware
 })


-----Editing/Updating an Object in DB----

 app.put('api/fooList/:id', (req, res, next) => {
 const body = req.body
 const foo = {
  datafield: body.datafield,
  datafield2: body.datafield2,
  //etc..
 }

  Foo.findByIdAndUpdate(req.params.id, foo, {new : true})
  .then(updatedFoo => {
    res.json(updatedFoo)
     })
    .catch(error => next(error)) //assuming an err handler middleware
   })

*^Important: by default, the updatedFoo receives the original document
  without modifications. Adding the optional {new: true} parameter causes the 
even handler to be called with the new modified document nstead of the original.

 



