node.js is a javascript runtime environment that works pretty much anywhere
(servers/mobile devices). 

command: node name_of_file.js 
just typing node lets you write js (just like irb for ruby) in command line
or browser console.



never define components inside other components. 

iterating through array in js:

arr.forEach(foo => {
	console.log(foo)
	})

Content of array can be modified even if the array itself is a const.
(The object itself is what can't change)


React prefers using immutable data structures: IE instead of 
modifying an array, use concat method to create a new one.

ex: const arr1 = [1, 2, 3]
    const arr2 = arr1.concat(4)

map method creates a new array that creates items iterating over each
element of old array.

ex: const a1 = [1, 2, 3] 
    const a2 = a1.map(foo => "<li>" + foo + "</li>")

Map is used a lot in react.

 
---------------Destructuring---------------------
unpacking values from arrays or properties from objects
into distinct variables.

^ex: const arr = [1, 2, 3, 4, 5]
     const [first, second, ...rest] = arr;

^ first is 1, second is 2, rest is [3, 4, 5].

you can also only unpack part of the array
^ex: 
    const x = [1, 2, 3, 4, 5]
    const[y, z] = x; 
^y is 1, z is 2. 


Can destructure objects:

const ComponentName = (props) => {

ex:  const { name, age } = props //Assuming props is an object w/ these fields

^this creates a hashtable w/e its called in JS containing fields from 
props object. 

You can even destructure props in the parameter call.

ex: const Component = ({ arg, arg }) => {
	.......
	return (
	......
       )
     }


---------------- Objects in js------------

created as object literal:

const object1 = {
	name: 'Tanaka Taro', 
	age: 42,
	job: 'Developer',
     } 

^fields can be accessed like methods or with brackets:
	ex1: console.log(object1.name)
	ex2: console.log(object1['name'])
^note in ex2 name has to be a string, or a variable assigned to a string.

can also add properties using same syntax:
	object1.newProperty = 'New data'
	object1['newProperty'] = 12345

----------------- Functions and #this ------------------

Not relevant in newer react version thanks to hooks, but good to know.

Can define functions for objects inside their definition (like in java)
ex: const obj = {
    name: 'Me',
    greet: function() { console.log('hello my name is ' + this.name)}
}

Can also define a function outside of the object creation.

obj.newMethod = function(){} 


#this works differently in JS, it is defined based on how the 
method is called. So if you use a reference variable to call a function
that has #this, it will think #this is the global object, not the specific
object. 

^you can get around this using the #bind method. 
ex: objName.methodName.bind(objName). 

Arrow functions shouldn't be used as methods for objects. 


---------------Classes-------------------

No class system like OOP languages, but features which makes simulating them
possible. 

syntax:

   class ClassName {
	constructor(x, y) {
	this.x = x
	this.y = y
	}
   foo() { 
   }
 } 

const newInstance = new ClassName(1, 2)

^Mostly used in old react projects, 'hooks' are the new thing. 

-------------Misc JS stuff---------

parseInt('42', 10)  <- turns '42' into 42. 
^(10 is the base, optional arg but should give) ex base would be 2 for binary.


can also use + operator to convert str to number. 

Object spread: 

 In practice { ...clicks } creates a new object that has copies of all of the 
properties of the clicks object. Then you can specify which parts should be
different. 


-----------Rendering--------------

Not a good way of rendering but it works: 

Re render a component on the page by calling ReactDom.render method.

^to cut down on repeated code, can assign it to a function.

ex: const refresh = () => {
	ReactDOM.render(<App foo = {bar}/>,
	document.getElementById('root')) 
	} 


When a component's state is changed (through a function call), 
that component is re rendered. 


------------------------ State & Hooks -------------

hooks may only be called from the inside of a function body that 
defines a React component.


In react NEVER EVER MUTATE STATE DIRECTLY (ex: foo++), instead create a 
new object with the updated state, and unchanging values copied over. 
(ex foo = foo + 1) 

^For arrays, the concat method creates a copy and adds the argument.

To edit an array index, create copy of array, change the index, then
setState of the array to that changed copy. (not 100% sure if best practice).


Hooks must not be called from inside a loop, a conditional, or 
any place that isn't a function defining a component. They need
to be called in the same order all the time. 

Hooks don't work inside classes, but you can use them instead of classes.

import React, { useState } from 'react' 

^useState function is a built in hook. it takes the initial state as an
argument and returns an array of two entries. First element is 
the initial state, second element is a function that modifies the state.

^good use for destructuring. ex:
	
import React, { useState } from 'react
   const App = () => {
       const [ counter, setCounter ] = useState(0)
    setTimeout(
	() => setCounter(counter++),  //nameless function
	  1000 //sets a timeout of 1 second after incrementing.
	)
     return (
	<div>{counter}</div>
	)
     }

note destructuring of useState to isolate value and modifier. 
React re renders the component when setCounter is called, which
means that the function body of the component gets re executed.

When useState is called a second time, it returns the new value 1. 


For more complex state, using the useState function multiple times to
create seperate 'pieces' of state is usually the way to go.


-------------------- Event Handlers -------------

In react, handling a click of a button is done by making 
a button element with the attribute onClick={functionName}

ex:   (in App w/ a predefined handleClick function)
	return (
	   <div> 
	   <div> {counter} </div>
	   <button onClick={handleClick}>
	    button text
	   </button> 
	  </div>
	)
	} 
^can also define the onClick function in the value assignment
of the attribute, but not recommended usually. 


Event handlers must always be a function or reference to a function.
Not function calls.

good ex: <button onClick ={() => setValue(0)}> 
^A nameless arrow function that only calls a function when clicked.

bad ex: <button onClick = {setValue(0)}>
^Calls setValue when the component is rendered, causing infinite recursion

^^Worth noting, shouldn't usually define event handlers in the attribute. 


A function call is only okay if that function returns something other than 
another function call(ie no infinite recursion). 

