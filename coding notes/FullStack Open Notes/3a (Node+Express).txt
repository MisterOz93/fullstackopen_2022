Creating an app through $npm init command goes through steps to create
a package.json file at root of the directory. 

in "scripts" object of package.json, add:

"start": "node index.js", 

Then, add an index.js file to root of the project. 

then you can type $node index.js to run the program.
^or run it as an npm script with $npm start
^(works because we added it to package.json)

$node in the command line starts an interactive repl (like irb)


**Note: Keep an eye on the terminal running the server when backend programming. picks up
errors and check behaviour to make sure its running as intended. 

To find out what Headers have been sent in http request (common source of bugs) is thru 
the get method of the request object for a single header. Also request.headers contains 
all the headers of a specific request.  

------Changing Application into a Web Server-------

*Refer to Express notes below for better set up*

index.js: 

const http = require('http') //basically like import http from 'http'

const app = http.createServer((request, response) => {
  response.writeHead(200, { 'Content-Type': 'text/plain' })
//^request is responded to with status code 200.
//'Content-Type' should be changed to 'application/json' if data
//is in json format.  
  response.end('Hello World')
})

const PORT = 3001
app.listen(PORT)
//^binds the http server to listen to http requests sent to port 3001
console.log(`Server running on port ${PORT}`)


---------_Express--------

Express is a library that helps build better backend server than 
Node's built-in http web server. 

$npm install express in project root to define it as a project
dependency (just like you did with axios). 

dependencies can be updated with $npm update.

To install all up to date dependencies of the project as defined in
package.json (ex: if working on project on another computer), run
command $npm install. 

backwards compatibility is ensured if the first number is the same
(ex: 4.11.2 and 4.999.999). 


---Getting started w/ express---
inside index.js:

const express = require('express')
const app = express()
app.use(express.json())

let fooObject = [
....
]

app.get('/', (request, response) => {
  response.send('<h1> Hello World!</h1>')
})

app.get('/api/fooObject', (request, response) => {
  response.json(fooObject)
 })

const PORT = 3001
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`)
 })


^ The app.get methods each define a *route* to the 
application. 

The first one defines an event handler that 
handles requests made to the application's /root. 
The first parameter (request) contains all the information
of the http request. The (response) parameter is used to 
define how the request is responded to. 

The status code of the response defaults to 200.

The second route defines an event handler that handles 
GET requests made to the fooObject path of the app. 

The request in the example is responded to by sending
the object array as JSON formatted string.
(Express automatically sets Content-Type to application/json)


---------- nodemon--------

$npm install --save-dev nodemon

^dev dependencies are only needed during development
(testing/restarting app), not needed in production mode
on a production server (ex: Heroku). 

nodemon watches files in the directory and if any files
change, nodemon restarts the node application.

^basically saves you from having to close server and boot it 
back up to see any changes. 

to run app w/ nodemon:

$node_modules/.bin/nodemon index.js 

^to make this shorter, add:

"dev:" "nodemon index.js", 

to "scripts" object in package.json. 

^^then, you can run it with npm run dev


--------REST-------

REST is architectural style meant for building scalable web apps.

Every resource (like an object) has an associated URL.

Convention is to create unique address for resources by combining 
name of resource type with the unique indentifier. 

^ex: www.example.com/api/fooObject/10  for the 10th item in fooObject array.

Can execute different options on resources based on the http verb:

GET/POST/DELETE/PUT/PATCH


---Route for Fetching a single resource---

app.get('/api/fooObjectList/:id', (request, response) => { //handles HTTP requests to /api/fooObjectList/SOMETHING (SOMETHING is an arbitrary string)
//^ the colon is a route parameter, to capture values specified at that position, and store it in request.params object with name of the parameter as the key
	const id = Number(request.params.id) //id was route parameter, thus value is stored in request.params.id
	^// Note that the route parameter returns the id as a string, so turn it into Number type if JS object's id is an integer. 
	const fooObject = fooObjectList.find (fooObject => fooObject.id === id)
	if (fooObject) {
		response.json(fooObject)
	} else {
		response.status(404).end() //if no data is found w/ matching id, send 404 and use end() method that returns no data. 
	})

^This doesn't notify the user that a 404 error occured, but for a REST API the error is all thats needed, 
whoever is using the API can program how to notify the user. 


-----Route for Deleting resources------

app.delete('api/fooObjectList/:id', (request, response) => {
	const id = Number(request.params.id);
	fooObjectList = fooObjectList.filter(fooObject => fooObject.id !=== id)
	response.status(204).end()
	})
^^204 is no content, and returns no data with response. Works for successful and unsuccesful attempts to delete. 
(could send 404 for unsuccessful, but 204 is fine).


---------Postman/REST Client-------

Postman makes testing the back end a lot easier. 

VS Code has plugin REST client you can use instead of postman.

Using VS Code plugin: 

Make a directory at the root of the application called 'requests' (sans brackets), 
then save all REST client requests in that directory as files that end in .rest
(ex: get_all_notes.rest for a file that fetches all notes).
	
Then by clicking the Sens Request url, the rest client executes the request and response
from the server is opened in the VS code editor. 

You can handle multiple requests in the same file using the ### seperators:

ex^ GET http://localhost:3001/api/fooObjectList
    ###
    POST http://localhost:3001/api/fooObjectList/ HTTP/1.1
    Content-Type: application/json
	//error if this line isnt empty
   {"name": "sample"
    "time": "..."
   } 

**Important**: In VS REST client, problems can happen if theres an empty line between the top row
and the row specifying http headers. REST client interprets this as all headers are left empty, so server
doesnt know data was sent in json format. 

----------_Receiving Data (Handling POST requests)--------

To easily access the data, do:

app.use(express.json()) to enable the express json-parser (can call it globally). 

example to handle POST:

app.post('/api/fooObjectList', (request, response) => {
 const body = request.body //json parser provides the body method by transforming request data into JS object
if (!body.content) {
 return response.status(400).json({  //make sure to return, or else a malformed object gets sent back w/o content
	error: 'content missing'
	})
     }

const fooObject = {
	content: body.content,
	date: new Date()
	id: fooObjectList.length > 0 ? Math.max(...fooObjectList.map( f => f.id)) + 1 : 1 
//^spread syntax is used to transform array into individual numbers that can use Math.max method. 
^// NOT RECOMMENDED WAY OF ASSIGNING ID, UPDATE WHEN BETTER METHOD IS SHOWN
  }
 fooObjectList = fooObjectList.concat(fooObject)
 response.json(fooObject)
}) 


------------HTTP REQUEST TYPES-----------------

HTTP standards have two properties: safety and idempotence. 

safety: executing the request only returns data, does not alter the database's state at all. 
^GET and HEAD must be 'safe' requests by convention.

Idempotence: If the request has side-effects (alters state of DB), the result should be the same no matter
		how many times the request is sent aside from error/expiration issues. 
^All HTTP methods except POST should be indempotent. (ex: sending the same PUT request once or 200 times should have the same total effect on the server)

---------------MIDDLEWARE---------------

Middleware are functions that can be used for handling request and response objects.
^ex: app.use(express.json()) //app being = express(); 
The json parser takes the raw data from the request stored in the request
object, parses it into JS object then assigns it to the request object 
as a 'body' property (sans quotes)

 
making a customer Middleware function takes 3 parameters:

const fooMiddleware = (request, response, next) { ..... } 

^next() is a function that yields control to the next middleware in 
the code.


Middleware are taken into use with: app.use(fooMiddleware)

Middleware functions are called in the order they're taken into use. 
(ex: a middleware using request.body would have to be used after json)

you can create middleware after all your routes, which you can use() 
to catch requests made to non existing routes. 


Note: I wasn't able to call app.use(middlewareName()) inside a route,
only globally. Could be specific, or general, or maybe my mistake? 


^ex: const unknownRoute = (request, response) => { // no next param?
      response.status(404).send({ 'error: unknown route' }) //they use 'endpoint'
	}
 app.use(unknownRoute); 


