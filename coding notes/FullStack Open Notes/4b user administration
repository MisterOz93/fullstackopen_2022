Example with a note creator app:

Every user should be stored in DB, every note should be linked with
the user who created it. Deleting/editing a note should
only be possible for that user.

In a relational DB (ex: SQL), both resources (users and notes) would
have seperate tables, and id of the user who created a note would
be stored in the note table as a foreign key.

In document DB (ex: Mongo), there are multiple options.

^If you don't want to change the existing collection of notes,
can create another collection of users. 
Then can use object ids to reference documents in other collections. 

Assume the users collection has 2 fields: username and _id,
then the notes collection should have a user field w/ the value
of _id from user who made it.

The foreign key can be stored in either note, or users, or both. 

^ex in users collection: [ 
	{username: 'Bob',
	  _id: 123456
	  notes: [11111, 22222, 33333]
	^//these values being the note's _id in notes collection
   }, //...


Or, could just nest an array of note objects in users, removing the
need for notes collection. It comes down to a design decision.

**** Example of Schema for Users ****

const mongoose = require('mongoose')

const userSchema = new mongoose.Schema({
	username: String,
	name: String,
	passwordHash: String,//explained below
	notes: [
	{
		type: mongoose.Schema.Types.ObjectId,
	//ObjectId type is used to reference other documents.
	//so i think it lets you reference notes as the notes of user
	//does notes.type point to note's ID or user's ID? I assume latter
		ref: 'Note'
	}
	],
    })

	userSchema.set('toJSON', {
	transform: (document, returnedObject) => {
	returnedObject.id = returnedObject._id.toString()
 	delete returnedObject._id
	delete returnedObject.__v
	delete returnedObject.passwordHash //so that its not revealed when JSON
	}
    })

const User = mongoose.model('User', userSchema)
module.exports = User

^ And then in the noteSchema:

//... 
user { 
	type: mongoose.Schema.Types.ObjectId,
	ref: 'User'
	}
//...

^Now note references the user who created it, and the user has an
array of references to all notes created by them.


----passwords---

never ever store unencrypted plain text pw in a db

the bcrypt package can be used for generating pw hashes.

bcrypt is good because it lets you scale how expensive the 
hash function is, so as computer gets faster the hash gets slower.
(or something like that, example is w/o it person could crack a pw
with an md5 hash function in 40 seconds, or 12 years with bcrypt)

$npm install bcrypt

then in the relevant /controllers/foo.js file (in this ex: users):

const bcrypt = require('bcrypt')

//...inside post route:

const { username, name, password } = request.body

const saltRounds = 10 
const passwordHash = await bcrypt.hash(password, saltRounds)

const user = new User({
	username,
	name,
	passwordHash,
    }) 

const savedUser = await user.save()
response.status(201).json(savedUser)
})

^the pw sent in the request isnt saved to db, instead its hashed
w/ bcrypt (dont worry about understanding the salts stuff, its just
for added security i think)


------To ensure a datafield value is unique in db-----

example is users must have unique username:

//inside usersRouter.post:

const {username, name, pw } = request.body

const existingUser = await User.findOne({ username})
if (existingUser) {
	return response.status(400).json({
	error: 'username must be unique'
    })
 }



----CREATE while assigning it to user who created it----

example of users creating notes:

//inside the notesRouter file:

const User = require('../models/user')

notesRouter.post('/'/, async (req, res, next) => {
  const body = req.body
  const user = await User.findById(body.userId) //unsure where this field is from
	
  const note = new Note({
	content: body.content,
	date: new Date(),
	user: user._id //remember _id is only changed to id for JSON
	})
  const savedNote = await note.save()
  user.notes = user.notes.concat(savedNote._id) 
  //^this updates the user object to add the new note's id into user's array
  // of notes.		
  await user.save()
  reponse.json(savedNote)
 })


----Populate----

When a get request is made to users, you might want the content of what they
created to be displayed, not just the ids. In a relational (ex: SQL) db, a
join query would accomplish that.

For document db (ex Mongo), accomplished thru Mongoose library doing
multiple queries. Important to note that while relational db join ensures
that DB state doesn't change during time the query is made,  Mongoose
cant garauntee that the state between collections being joined is consistent.

Mongoose join is done with populate method:

usersRouter.get('/', async (request, response) => {
  const users = await User.find({}).populate('notes')
  response.json(users)
  })

^chained with find, parameter given to populate defines the ids that 
reference note objects in the notes field of the user document will be 
replaced by the referenced note document 
^(I think this is where 
*notes: [{type: mongoose.Schema.Types.ObjectId, ref: 'Note'}],*
in user schema comes into play.?)

Can further specify what you want in populate parameter:

^ex: const users = await User.find({}).populate('notes', {content: 1, date: 1}

^Meaning only content and date will be showed (along with original id?)


Doing the opposite in notesRouter so that it gives information on
user who created the note:

notesRouter.get('/', async (req, res) => {
 const notes = await Note.find({}).populate('user, {username: 1, name: 1})
 response.json(notes) });


Important: The DB does not actually know that the ids stored in user field
of notes reference documents in the 'user' collection. The reason populate
works is because we have defined 'types' to the references in the schema
with the ref option

^ //in noteSchema
 user: {
	type: mongoose.Schema.Types.ObjectId,
	ref: 'User'
	}
})

