 	--------Project Structure-------

Rather than putting a ton of things in index.js
(like the app, routes, and error handler),

instead, its better to structure it so that the root directory has:

index.js, app.js, build (dir), 
controllers (dir w/ files that handle HTTP routes. routes related to Foo
in Foo.js module in dir.), 

models (dir w/ mongoose schema and fooRouter*, note that connecting to DB
is in app.js), 

^* const fooRouter = require('express').Router();
//at bottom: 
 module.exports = fooRouter. 

All routes are now defined for the router object, and instead of
writing the entire path as a parameter (ex: app.delete('api/notes/:id',...
instead:

fooRouter.delete('/:id', (req, res) => {...}

^The router is a built in middleware, app.js puts it into use 
IF the url of the request starts with the first argument of app.use

//in app.js:

const fooRouter = require('./controllers/foos') //importing
app.use('/api/foos', fooRouter) //fooRouter is used if the URL of the 
request begins with /api/foos.  

package-lock, package,

utils dir with these files:
    config (handling environment variables like PORT and MONGODB_URI),
    logger (generic console.log functions, ex:
         	^ const info = (...params) => {
	  	console.log(...params)
	  	}
	       const error = ///(same as info),
    middleware ( custom middleware like requestLogger, unknownEndpoint, &
		errorHandler)

index.js itself is now just:

  const app = require('./app')
  const http = require('http')
  const config = require('./utils/config')
  const logger = require('./utils/logger')

  const server = http.createServer(app)
  server.listen(config.PORT, () => {
         logger.info(`Server running on port ${config.PORT}`)
  })


app.js file is: 

const config = require('./utils/config')
const express = require('express')
const app = express()
const cors = require('cors')
const notesRouter = require('./controllers/foos')
const middleware = require('./utils/middleware')
const logger = require('./utils/logger')
const mongoose = require('mongoose')

logger.info('connecting to', config.MONGODB_URI)

mongoose.connect(config.MONGODB_URI)
  .then(() => {
    logger.info('connected to MongoDB')
  })
  .catch((error) => {
    logger.error('error connecting to MongoDB:', error.message)
  })

app.use(cors())
app.use(express.static('build'))
app.use(express.json())
app.use(middleware.requestLogger)

app.use('/api/notes', notesRouter)

app.use(middleware.unknownEndpoint)
app.use(middleware.errorHandler)

module.exports = app


For the full picture of whats in each part:
https://github.com/fullstack-hy/part3-notes-backend/tree/part4-1

its not a requirement to do it like that, but its good to seperate things
especially in larger projects.

^Make sure in app to use() express.json() before use()ing any Routers. 


----------- Node Testing --------

----Start up----

1. $npm install --save-dev jest

2. in package file "scripts" object:
   "test": "jest --verbose"

3. in package file [inside the main doc object]: 
	"jest": {
             "testEnvironment": "node"
		}
^alternative to 3: create jest.config.js file, inside:
	module.exports = {
	  testEnvironment: "node",
	}; 
4. Create a 'tests' directory to put unit tests in. 

5. If using eslint, add 'jest': true into 'env' object in .eslintrc.js file.

6. If testing a function foo, create foo.test.js in tests dir. 

7. $npm test

------Unit tests-----

For a unit test of method foo:
1. const foo = require('../dirName/fileWithFooMethod').foo

individual test cases are defined w/ 'test' function (sans quotes)
1st arg of test is the test description (a string), 2nd param is a
function that defines the functionality for the test case. 

^ex testing a function #reverse that reverses a string: 
	test('reverse of react', () => {
	       expect(reverse('react')).toBe('tcaer')
               })

^expect wraps the resulting value (reverse('react')) into an object that 
has 'matcher' functions, such as toBe. 

A #describe block can be defined around multiple tests to group them 
logically. Describe blocks are needed to run some shared setup or teardown
operations for a grp of tests (more on that later).

^ex:
	describe ('reverse', () => {
	//tests
	})


add the #only method after #test (test.only(...)) to only test that/those
with $npm test. 

expect(foo).toBe(value) vs. toEqual(value)

^toBe checks if its same object in memory. toEqual just checks value.



--------Testing the backend----------

If the app's backend is relatively simple (ex: CRUD), you cn test through its
REST API, so that the databse is also included. Testing when multple components 
of the system are being tested as a group is called 'integration testing'.


***test environment***

Node convention is to define the execution mode of the application 
with the NODE_ENV environment variable. 

^In package.json "scripts" object:

"start": "NODE_ENV=production node index.js",
"dev": "NODE_ENV=development nodemon index.js",
"test": "NODE_ENV=test jest --verbose --runInBand"	
//^runInBand prevents jest from running tests in parallel


^this means npm start will define the mode as production, but npm run dev
defines development.  

**These scripts won't work on Windows, can correct this by:
1. $npm install --save-dev cross-env
2. add "cross-env" before NODE_ENV in the "start" "dev" and "test" strings
in "scripts" object. 
3. (if deploying app to heroku) $npm i cross-env -P //cross-env is added as
//production dependency

^^^All this setup lets us modify the way the app runs in different modes. 
ex: could define the app to use a different database when running tests.
In a real scenario, usually each developer has a local database for testing, since a 
single database instance shouldn't be used by concurrent tests. 


To use a different DB for testing:

1. //In config file:

require('dotenv').config()

const MONGODB_URI = process.env.NODE_ENV === 'test' 
  ? process.env.TEST_MONGODB_URI
  : process.env.MONGODB_URI

2. in .env file:

TEST_MONGODB_URI= //(the URI, but change the part after .net/ and before ? 
	to change name of the DB


*****supertest*****

$npm install --save-dev supertest

^now create a foo_api.test.js file in tests dir:

const mongoose = require('mongoose')
const supertest = require('supertest')
const app = require('../app')

const api = supertest(app)
^//wraps the express app into a 'superagent' object

test('foos are returned as json', async () => {
  await api
    .get('/api/foos')
    .expect(200)
    .expect('Content-Type', /application\/json/) 
			  ^//regex, the \ before /json indicates the / is a
			   //character in the pattern
})

afterAll(() => {
  mongoose.connection.close()
})


^The 'superagent' object assigned to api variable can be used in tests
for making HTTP requests to the backend. 

^^more on asynch/await below
^^^ afterAll is executed after all tests are done.

^^^^supertest makes sure app being tested is started at the
    port it uses internally, so you dont need to require index.js
    (or wherever the app.listen is defined) 

**Note: Jest and mongoose can have issues:

1. 'Jest did not exit one second after...' msg
	^Solution: add --forceExit in "test" string in package.json
2. test takes longer than default 5000ms timeout. 
	^Solution:add 3rd parameter to test to set timeout ms. 
	^ex: test('foo works', async () => {...}, 10000). 

To test the contents of the db:

example: 

test('the first blog is called: How to blog', async () => {
  const response = await api.get('/api/blogs')
  expect(response.body[0].title).toBe('How to blog')
})

^async/await lets us bypass using callback functions to access
data returned by promises. execution only gets past #await after 
the request is complete (?).


Note: these tests aren't great because they rely on external state of DB

-----Initializing DB before tests---------

import the /models/ file w/ the schema, then 

create const initialFoos = [
 { ... }, {...} //etc] 

beforeEach(async () => {
  await Foo.deleteMany({}) //clears out the db
  let fooObject = new Foo(initialFoos[0])
  await fooObject.save()
  fooObject = new Foo(initialFoos[1])
  await fooObject.save()
})

----------async/await-----

code execution pauses at await, and waits until the promise is fulfilled
then continues to next line. 

^ex:  
const exampleFunction = async () => {
      const foos = await Foo.find({})
      const response = await foos[0].remove()
}

^Replaces the need to chain .then(()=>{}) 

await keyword can only be used inside of an async function. 

^ex: fooRouter.get('/', async (request, response) => {
      const foos = await Foo.find({})
      response.json(foos)
  })

----testing POST method---

example:

test('a valid foo can be added', async () => {
	const newFoo = {
	fieldOne: '...'
	fieldTwo //etc.
}

  await api
   .post('/api/foos')
   .send(newFoo)
   .expect(201)
   .expect('Content-Type', /application\/json/)

  const response = await api.get('/api/foos')

  const dataFieldName = response.body.map(r => r.dataFieldName)

  expect(response.body).toHaveLength(initialFoos.length + 1)
  expect(dataFieldName).toContain(foo)


---extracting test db helper into module---

its good to have a file to contain all the preparatory test db work

ex: tests/test_helper.js:

const Foo = require('../models/foo')

const initialFoos = [
 {...}, {...}]

const foosInDb = async () => {
   const foos = await Foo.find({})
   return foos.map(foo => foo.toJson())


----error handling w/ async/await ---

The recommended way to handle exceptions is with try/catch blocks.

^ex: fooRouter.post('/', async (req, res, next) => {
	const body = request.body
	const foo = new Foo({
	   dataField = body.dataField, 
	   /...etc
	   }) 
	try {
		const savedFoo = await foo.save()
		response.status(201).json(savedFoo)
	 } catch(exception) {
	next(exception) //assuming you defined error handler middleware
	}
	}) 


-----Testing GET individual object ----

ex test:
	const foos = await helper.foosInDB() //get request and then map to json
	const fooToView = foos[0]
	const resultFoo = await api.get(`/api/foos/${fooToView.id}`)
				   .expect(200)
				   .expect('Content-Type', /application\/json/)
	const processedFooToView = JSON.parse(JSON.stringify(fooToView))
	//^This might not be necessary? might depend on dataField types?
	expect(resultFoo.body).toEqual(processedFooToView)
	})

---- Testing DELETE individual object ---

ex:
	const initialFoos = await helper.foosInDB() //get then map to json
	const fooToDelete = foos[0]
	await api.delete(`api/foos/${fooToDelete.id}`)
		  .expect(204)
	const foosAtEnd = await helper.foosInDB()
	expect(foosAtEnd).toHaveLength(helper.initialFoos.length -1)
	const dataField = foosAtEnd.map(f => f.dataField)
	expect(dataField).not.toContain(fooToDelete.dataField)
	//^ assuming dataField is unique for each foo


--------Alternative to try/catch for async/await-----

$npm install express-async-errors
require('express-async-errors') // in app.js 

^this library makes it so that any exception in an async route is
automatically passed to error handling middleware. 


---Adding objects to test db----

Instead of hard coding 
^ex: let fooObject = new Foo(helper.initialFoos[n])
	await fooObject.save()


Instead of doing that for each foo in initialFoos, instead:

beforeEach(async () => {
 await Foo.deleteMany({}) //clear the db
 
 const fooObjects = helper.initialFoos.map(foo => new Foo(foo))
 const promiseArray = fooObjects.map(foo => foo.save())
 await Promise.all(promiseArray)
})

^ A simple forEach thru initialFoos wouldn't work, because each
 iteration of forEach generates its own async operation that beforeEach
won't wait for. Results in tests starting before db state is initialized.

Promise.all transforms an array of promises into a single promise that will
be fulfilled once every promise in the array is resolved. so
await Promise.all(promiseArray) waits for all the foos to save to the db.

^Promise.all executes in parallel (meaning order isnt guaranteed), if 
promises have to be a certain order, then do a for loop:
  for (let foo of helper.initialFoos) {
	let fooObject = new Foo(foo)
	await fooObject.save()
	}
    })


