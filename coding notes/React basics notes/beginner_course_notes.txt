To start building UI with JS you need a root element to append elements to the 
document. The element is where you append your created elements with the
#document API (getElement/createElement). 

^ex: <div id="root"></div>

then in script:

const rootElement = document.getElementById('root')
rootElement.appendChild(foo) <- foo becomes child of root in DOM. 


^That's using vanilla JS.

You can quickly add react to the file by going to 
unpkg.com then finding a link for react.development.js 
and react-dom.development.js

then make script tags:
<script src="https://#link for react#></script>
<script src="https://#link for reactdom#></script>

Then you can use ReactDOM.render(foo, rootElement)

^create foo using React.createElement(type, {

}
)
^ex: type might be 'div', then second arg is object with the props
you want to apply (can be null).


For React.createElement, every arg given after the props object are
considered children of that object.


^this way isn't recommended, instead use JSX (which requires Babel to compile).


You can add babel to the page same way as React/React DOM. through unpkg
link in script tag.

Then wrap the JSX code in <script type="text/babel"> tag. 

^You wouldn't want to use Babel in the browser for production, but ok for 
messing around and stuff.

JSX allows for self closing <div   /> tag. (unlike HTML). 

You can use spread operator ... to spread props to a JSX element.
ex:
const props = {name, age} 
const element = <div id="app-root" {...props} /> 

^That gives element all the props. 


A react element can't return two react elements. 

(ex: ReactDOM.render(foo, bar) won't work, since its trying to return two 
elements.)

The React.Fragment type lets us put elements side by side without needing
a div between them.

^React.Fragment shorthand is <> </> that you already learned in FSO. 

You switch back and forth btwn JSX and JS when writing react. JS can be 
written in JSX using {}. But {} inside JSX can only be expressions, not stuff
like loops or if statements (unless ternary). 

^Remember that JSX is basically using the React.createElement function, so
you couldn't make a loop or conditional an argument of that function.

You're inside JSX when in tags (like <div> </div>) (when in script tag)


When you give elements to ReactDOM.render(foo,bar), React compares elements
you return this time with elements you returned last time, and will update
only the things that are different. 


Styling react components: style prop accepts an object. 

^ex: <div style={{fontStyle: 'italic', backgroundColor: 'lightblue'}}>

^note the camelCase.

To avoid repeition, use a function with props argument. 

Returning spread props {...props} will override or be overriden if it contains
a prop that you're returning manually. Destructure the props to get around that.

ex: function Foo({props}){ return ( <div singleProp='red', {...props} />) }

^instead: function Foo({singleProp='red', ...rest}) 

This way, ...rest doesn't include the singleProp and avoides overriding.


<Consider rewatching video 11. Got hard to follow, but move on for now>

Tailwindcss recommended.


htmlFor <- attribute to link a label to an input field.

ex: <form> <label htmlFor="name">Name: </label>
	   <input id="name" />
	</form>

^html equivalent is "for". (Rare difference in syntax w/ JSX). 


React hooks maintain state for components. 

foo = React.useState(defaultValue) Remember this returns array of current
state and change state. 

^destructure the array, don't assign using indicies. 

ex: const [name, setName] = React.useState('')


useState has a lazy initialization feature by providing a function
as the initial value, this way the value is only rendered on 
initialization and not on each rerender for performance. 
^important when reading into local storage, which is done with 
useEffect hook. 

React.useEffect allows a 2nd parameter, a dependency array to sync the
state of the world with the state of the application. Need to keep the 
array accurate to syncronize the state of the application. 

^ex you type in something, then refresh the page, and what you typed in is
gone. 

Use eslint-plugin-react-hooks to keep dependency array updated. 

You can write hooks in functions to store them, and then call that function.
Function can return an array of [state, setState] just like useState() does. 

Convention to name custom hook functions starting with "use" prefix. 

Interacting with the DOM is a 'side-effect', which works with
the React.useEffect() hook. 

Data fetching, subscriptions or manually changing the DOM from components
are "side effects/effects" because they can affect other components and can't
be done during rendering. 

the useEffect hook lets you perform side effects from a function.

useEffect hooks are called after React finishes rendering.
useEffect is only called when there are no dpendencies or one of 
them change.

^A useEffect with an empty dependency array is never(?) called after the component
is first rendered. Unless the component is unmounted (removed from DOM). 

the useRef hook lets you create a reference to the dom element in the function
component. This hook returns an object that has a current property whose
value is the arg passed to useRef.



-------------Forms-----------

<form> </form> element put in component return statement. 

React only calls functions when the component is rendered.

submitting a form automatically sends a post request to the current URL. 

To prevent the form from being posted (and refreshing the page):

add the onSubmit attribute to <form> with a value of {handleSubmit},
and define handleSubmit as:

function(handleSubmit(event) {   //This is nested in another function in video
event.preventDefault()}		// not sure if that affects things.
} 

^in that function you can assign a variable to event.target.elements.foo.value

where foo is the id of the input tag in the form.

Don't use document.querySelector('input') to grab an input's value, it creates
conflicts with multiple inputs. Instead use the event.target.elements.foo.value

Always give a type attribute to buttons in forms, default value is submit.


For dynamic forms (that update), add the onChange={handleChange} attribute to the
<input /> tag. 

Remember React.useState() hook for keeping track of state. 

ex: if you need to know what user is typing in input field:

const[foo, setFoo] = React.useState('')

function handleChange(event) {

	setFoo(event.target.value)  
//setFoo being 2nd element of React.useState()
} 

^This will rerender the component whenever foo is changed in the input field.


Controlling input values in forms:

add a value prop inside the <input /> tag with the value of {foo} where 
foo is the current state. 

Rendering array of elements: 

When rendering an array of react elements, each element needs a key prop
associated with it. 

ex, when using map to iterate over every element, add a key attribute 
somewhere in the element (ex: inside <li> tag or <div> tag.) with a value of
an id that UNIQUELY identifies the item. 

^The key attribute lets React know if elements were added or removed between
renders. Make sure each key is unique for each element. 

Using the index as key doesn't work, because when React compares new version
with prev version, it maintains the same state as before because it doesn't
know which element points to which index both times. (smthng like that).

Lifting state:

If you need to share state between two sibling components (share the same
parent), you "lift" the state to the closest shared parent component.

^What this means is moving the useState function into the parent, and 
then passing a function through props (in the component that you took 
the useState from) 
ex:  function Foo({foo, changeFoo}) <- then in the return body set foo={foo}
and changeFoo={changeFoo} inside the tag. Then what you want to do 
on change can be defined inside the prop definition in the parent component.


Colocating state:

Opposite of lifting, bringing it back to the child component. 

HTTP requests:

useEffect hook is used for HTTP requests. Need to know json/graphql 
to fully understand.


Handling HTTP errors:

useState hook for error [error, setError].

Also, useState is good to differentiate between 'idle' 'pending' 'rejected'
and 'successful' when making server requests. 

React dev tools very useful, can change state/props. can use profiler to
examine renders and speed. Other stuff too. Refer to vid 28 for specifics. 

If you have components tab open, hit escape to bring up console, type $r 
to see information about currently selected component. 


Codesandbox.io is a great site to build an app online. Can connect with
github to create repos. Also can deploy it with netlify to put it on the 
web and connect it with your github. 

 


