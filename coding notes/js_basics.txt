Note, for JS triangle brackets <> arent used, im just using them here and 
there to denote keywords and or examples. 


To link an external js document to HTML:

<script src="filename.js"> </script>



Variables = containers that store values, use <let> to declare a variable:
ex: let <myvariable>; 

then give it a value: <myvariable> = 'Bob'; (or let <myvariable> = 'Bob';)

"retrieve" the value by typing variable name: <myvariable>; 

Can change value later in code

basic rule of thumb is to have one action per line of code 

------------------------------ ---------- Data Types
There are 8 main data types in Js, variables can be any type and arent bound
to one. This is called a "dynamically typed" programming language.


String: Sequence of text (ex: let <myvariable> = 'Bob')
backticks (`x${}`) are used to wrap a variable or expression as part of a string
ex: alert ( `the result is ${1+2}` ) <-- This pops up as "The Result is 3"
Without the backticks, it would pop up as "The result is 1+2" 

Number: (ex: let <myvariable> = 10;)

BigInt: rarely used, but for super large numbers. add an "n" to the end 
of a number when making it a BigInt 
(ex: const BigInt = 12348513205i20582352385912519284129n;)

Boolean: true/false (ex: let <myvariable> = true;)

null: it represents nothing, empty, or value unknown

undefined: initial default value

Array: Allows storying of multiple values 
(ex: let <myvariable> = [1,'Bob','Steve',10])

Object: Can be anything in JavaScript (to be continued)

symbol: used to create unique identifiers for objects (to be continued)

typeof: operator that tells you what the type of data is 
syntax is typeof x or typeof(x)
-------------------------------------------------- Comments

Same as CSS, ex: /* <insertcomment here> *\

--------------------------------------------------- Operators

+ : Adds two numbers or combines strings (ex: 'Hello' + 'World' ;)
- / *: Subtracts, divides, multiplies
=: Assigns value to a variable (let <myvariable> = 'Bob' ;)
+variable turns the variable into a number 
+=: adds two arguments (ex: x += y is the same as x = x+y)
-=: (x = x-y)
*=: (x = x*y)
/=: (x = x/y)

===: Performs test to see if two variables are equal (<myvariable> === 4;)
!: Not, gives opposite of true/false. 
(I think, so if variable === 3; is TRUE, !variable === 3; would be FALSE)

------------------------------------------------------ Conditionals
if.... else statement. Does x if y, or else does z 

ex: if(iceCream === 'chocolate') {alert('Yay, I love chocolate!');} else 
{alert('Aww, but I wanted chocolate!');}

^ Performs a test in the brackets, gives diff response whether true or false.

----------------------------------------------------------Functions

Package a body of code as a function that you can reuse 

ex: function multiply(num1,num2) {let result = num1 * num2; return result;
}
^ Takes two numbers and multiplies them. 

------------------------------------------------------------- Events

Events run code in response to something happening (ie a mouse click)

-----------------------------------------------------
let variablename = value; <- basic syntax to declare a variable.
^or var name = value; 

to round a decimal, create a new variable that =decimal.toFixed(placesrnded)
(ex: let twoDecimalPlaces = lotsofDecimal.toFixed(2) ) 
 
typeof variablename <- shows what type of data the variable is

To make a string act like a number do:
(the word) Number(variablename) + 3;
or +(variablename)  

------------------------------------------- Comparison operators

=== Strict equality
!== stritch non equality
< less than
> grtr than
<= less or eql
>= grtr or eql

--------------------------------Precendence 

17 	unary plus 	+  (aka turning variable into number)
17 	unary negation 	-
16 	exponentiation 	**
15 	multiplication 	*
15 	division 	/
13 	addition 	+
13 	subtraction 	-
… 	… 	…
3 	assignment 	=
… 	… 	…
------------------------------

Increment/Decrement (++/--) only works w/ variables, not basic numbers.


When the operator goes after the variable, it is in “postfix form”: counter++.
The “prefix form” is when the operator goes before the variable: ++counter.

^ The value that you get returned depends on whihch is first

Increment/Decrements work inside expressions and have very high precendence. 
ex: let counter = 1; 
alert( 2 * ++counter); comes out as 4. 
note: better to have one action per line
ex: let counter= 1;
alert( 2 * counter );
counter++;

------------------------------------------ Variables

Variables are named storage for data

let <- keyword that declares(creates) a variable
Use a single variable per line for readability

variable names can only have letters, digits, $ or _
first character of a variable cant be a digit

when naming variable w/ multiple words, each word except 1st should
start w/ capital letter (ex: let myVeryLongVariableName)

using const (for constant) instead of let creates an unchangeable variable.

Standard practice is to name a const in ALL_CAPS ONLY IF 
its a hard to remember pre-known value. (ex hexadecimal color scheme) 

------------------------------ Variable Naming Practices


Use human-readable names like userName or shoppingCart.
Stay away from abbreviations or short names 
like a, b, c, unless you really know what you’re doing.
Make names maximally descriptive and concise. 
Examples of bad names are data and value. Such names say nothing. 
It’s only okay to use them if the context 
of the code makes it exceptionally obvious which 
data or value the variable is referencing.
Agree on terms within your team and in your own mind. 
If a site visitor is called a “user” then we should name 
related variables currentUser or newUser instead 
of currentVisitor or newManInTown.
---------------------------------------
To round a decimal: 

var n = num.toFixed(2);

Syntax: number.toFixed(x) <- x is # of decimals. 

-------------------------------------------------------- Strings 

when writing a string, need to surround value in quotes (ex: let string = "hi")
If quotes arent used, browser assumes text to be variable name instead of value

To "escape" characters in a string (ie making sure the browser treats it
 as text and not code) put a \ right in front of the character (ex I\'ve) 

Concatenate is a fancy programming word that means "join together". 
Joining together strings in JavaScript uses the plus (+) operator
ex: alert("Hello " + name + "nice to see you!")

to convert a number into a string:
let <name of number> = <number>;
let <name of string> = <name of number>.toString()
^you now have a string thats the same as the number

or to convert string into a number:
let <name of string> = "stringname"
let <name of number> = Number(name of string)
^you now have a number w/ the string's value. 

----------------------------------------------- Template literal
aka: newer syntax for more flexible strings

replace "" with backticks `` so that when concatenating you can just use ${}
when using strings with quotation marks. 
If using quotations, make sure to refer to escape method above. 

To make a string appear over multiple lines, use \n to signal a linebreak. 
^ Template literal doesn't require a \n (use shift/enter to go down)

Use the template literal approach ` ${}` 

--------------------------------------------- string properties
string length:
let <stringx> = "x"
let <stringy> = x.length; 
^ stringy gives you the length of string x  

Finding a string in a string:
let <stringx> = "abc"
let <stringy> = stringx.indexOf("b");
^ stringy tells you where "b" is first located in stringx (
counting from 0 not including quotation marks) lastIndexof() finds last location

^ can also use stringx.search("b"); note that this method doenst allow for
a custom start position (indexOf does using a comma and number after the "")


slice() <- extracts a part of a string and returns it to a new string

syntax: slice(startposition,endposition)
ex: let str = "Apple, Banana, Kiwi";
    let res = str.slice(7, 13);
res will take the string from position 7 to 12 (the end is not included**)
^Remember Js counts from 0. 0=A, 1=p, 2=p,3=l,4=e, 5=,, 6= , 7=B,etc 

^Can also slice using negative (-7, -13) that goes backwards from end.

^substring() works the same, but doesnt use negatives.

substr() is similar, but 2nd coordinate represents how many total characters
to slice. 

replace() <- replaces selected part of string(x) with something else(y)

ex: let str = "Please Visit Microsoft!";
    let n = str.replace("Microsoft", "W3Schools");

^note: doesnt actually change the string, just makes new one.
^note: only replaces 1st occurance, for all use /g with word (rplc " w/ / ) 
ex: n = str.replace(/Microsoft/g, "W3Schools"); 

.toUpperCase() <- changes string to uppercase (dont forget the . )
ex: let text1 = "hi"
    let text2 = text1.toUpperCase()
^ same w/ toLowerCase

concat() <- works the same as using + to add strings
ex: let text1 = "Hello";
    let text2 = "World"; 
    let text3 = text1.concat(" ", text2);

trim() <- removes whitespace from both sides of a string
ex: let str = "     Hello World!    ";
    let str2 = str.trim();

charAt() <- returns a character at a specific position in a string
ex: let str = "Hello";
    str.charAt(0);
^Returns H 
^ charCodeAt is the same but returns the UTF-16 code


Property Access (?)

need more info abt this, but syntax is: string[number] (ex str[0];)


split () <- converts string into an array
ex: let txt = "a,b,c,d,e";
txt.split(","); <- Split on commas (commas seperate each string in the array)
ex: let splitContact = contacts[i].split(':');
^ this would split the strings in the contacts array (up to i) and make
each a new string inside the new array splitContact. 

txt.split(" "); <- split on spaces
txt.split(""); <- split in characters


---------------------------------------------Comparisons
remember == is used for testing equality. = is used to assign values
!= is syntax for not equal

letters are compared with later in the alphabet being greater
(ex: Glow > Glee) 
^ note this applies to numerical strings too (ex: "2" > "12") 

comparing different types of data converts values into numbers
ex: "2" > 1; is calculated as 2 > 1 


for booleans, true ==1, false ==0 

== cannot differentiate between 0 and false,
so if you need to use === (this doesn't convert the data type)

ex: alert ( 0 == false); <- true
    alert (0=== false); <- false (since data types are diff.) 

in general, avoid using null or undefined in comparisons. 

------------------------------------------------------------ Conditionals (2)

if <- specify block of code to be executed if condition is true
else <- specify block of code be executed if same condition is false 
else if <- specify a new condition to test if 1st condtion is false 
switch <- specify many alternative blocks of code to be executed

syntax: 

if (condition) {
		  // code here
		} else {
		  // code here
		}

^If using an else if (condition 2), put it between 1st if and else, so program
checks first condition, then checks condition 2 if 1 is false, then does else
if both conditions are false. 

example: 
if (time < 10) {
  greeting = "Good morning";
} else if (time < 20) {
  greeting = "Good day";
} else {
  greeting = "Good evening";
}

------------------------------------- Logical Operators 


There are three logical operators in JavaScript: 
|| (OR), && (AND), ! (NOT).


|| OR is usually used in an "if" statement:

ex: 
let hour = 9;
let isWeekend = true;
if (hour < 10 || hour > 18 || isWeekend) { 
  alert( 'The office is closed.');
}

^Self explanatory, it gives more possible conditions.

|| checks operands from left to right, and returns the first one that's
true (in boolean logic). If they're all false, it returns the last one.

|| is also useful if you want something to happen *only* if something is false
ex: true || alert("not printed");
     false || alert("printed")
^ The first line never results in an alert since || stops at true. 
So nothing happens if whatever the condition is true, only if its false. 


&& (AND) 

ex: let hour = 12;
    let minute = 30;

     if (hour == 12 && minute == 30) {
     alert( 'The time is 12:30' );
     } 

With multiple && values, it evaluates from left to right and converts 
operands into boolean. If result is false, it stops and returns 
original value. So it returns the first falsy or the last value if none.

*** IMPORTANT** || returns first truthy, && returns first falsy 

! (NOT) syntax: result= !value
ex:   alert ( !true);  <- returns false 
      alert (!0); <- returns true

!! (double NOT) inverses, then reverses, but converts the 
value to boolean. Note that ! has the highest precedence of the logical operatrs


Possible combinations for ||

alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false

Combinations for &&

alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
-------------------------------------

Can simply use a variable name (assuming it exists) as a conditional 
thats always true.

Its ok to nest if else conditions

**NOTE: if (x === 5 || 7 || 10 || 20) <-wrong format (numbers alone are true)
        if (x === 5 || x === 7 || x === 10 ||x === 20) <- good format

-------------------------------------------------SWITCH STATEMENTS

take a single expression/value as an input, and then look 
through a number of choices until they find one that matches that value, 
executing the corresponding code that goes along with it

Syntax:    switch (expression/value){
		case "choice1":
			code to run if match
			break;

		case choice2:
			code to run if match
			break; 
		//etc etc
		default:
		 code to run if nothing matches
		}

^ You can use as many cases as you want, the break statement causes it to stop
after getting a match. Default is optional to include, but important if 
you arent guaranteed to get a match.

can use multiple cases for a code block, just add : btwn em.
note, switch is not good to use when using comparisons (> / < etc)

------------------------------------------------ Ternary/conditional operator 

 tests a condition and returns one value/expression if it is true, 
and another if it is false

syntax:  ( condition ) ? run this code : run this code instead

can use multiple ? in a code
ex: (condition) ? 'x' : (condition) ? 'y' : (condition) ? 'z' : 'a'

^ x if first condition is met, y if second, z if third, or a if none. 
Basically, ? acts as if, and : acts as else (I think). 

-------------------------------------------------Functions

Code that does a single task in a defined block, and can then be called to
be used whenever you need it. 

Make sure function is named clearly, and it should be limited to doing one 
thing per function. 

things like replace() random() join()

You can use functions inside functions

Delcaring a function:

function myFunction() { code;}


Invoking a function:

myFunction();

You can declare a function with no name (anonymous function)

function()  <- this is generally done with an event handler (ex .onclick)
so that the function is run when w/e it's attached to is clicked.

can also give a variable to an anonymous function. But its more clear 
to just use the basic: function functionName() {code} syntax

Generally, reserve using anonymous functions for events

^ex: myButton.onclick = function() {
	alert('hello');
	}

Some functions require parameters(aka arguments/properties/attributes
^ex: let newString = oldString.replace('texttoremove', 'texttoadd');

Use commas to seperate parameters. 

--------------------------------------------- Function Scope

Everything inside a function is defined within the scope of the function, 
meaning they aren't accessed by the code outside of the function.

Global scope = The top level outside functions, values in global scope can be
used anywhere. 

Keeping parts of code locked away in their own functions is best practice
so that you don't have to worry about name conflicts

Remember that parts inside a function only work within that function.
IE a variable delcared in a function only works in that function. 

Global scope is very rarely used. Try to make variables inside functions. 

-------------------------------------------- Function Nesting

Breaking a large function into smaller functions is better for readability.

ex: function myBigFunction() {
	let myValue;

	subFunction1();
	subFunction2();
	subFunction3();
	}

^important: each sub function would need to be set up below in their own {}
and make sure whatever the sub functions are doing are properly in scope 
ex: subFunction1(myValue); <- if function is using myValue. 

--------------------------------------------- Return values
Important to keep in mind what return value you'll get from a function.

Return value generally used when a function is doing a step in a larger process
this way the return value can be stored in a new variable to continue the 
process. 


Use the return keyword *inside* a custom function to specify the value 
returned. 

IMPORTANT: never seperate your return value from the return keyword
on a different line, Js assumes a semicolon after return in that case.
Make sure to start the return value on the same line. 

Use return with no value afterwards to immediately stop a function, handy 
for if/else.

ex: function showMovie(age) {
	if ( age < 18 ) {
	return;
              }
	alert ("Showing you the movie");
}

the function ends and doesn't show the alert if age < 18.

---------------------------- Difference between parameter and argument

ex: function favoriteAnimal(animal) {
	console.log(animal + " is my favorite animal!"
     }

	favoriteAnimal('Goat') 


^ In this example, (animal) is the parameter, its a placeholder so that we
know what we want to get out of the function. You can put anything in the 
parameter as long as you reference it properly in the function. 

('Goat') is the argument, it is what we are telling the code we want 
(animal) to be interpreted and represented as. 


Default parameters can act as backups to use incase that parameter isn't 
referenced in the function.

ex: function showMessage(from, text = 'no text given') {
 	alert( from + ": " + text ); 
	}
	
    showMessage ("Ann");

^This returns: Ann: no text given     because when invoking the function, 
"Ann" is evaluated as the from parameter, and since the text parameter isn't
given when the function is called, it uses the default 'no text given'. 

Default parameters can also be other functions and more complex stuff too. 

---------------------------- Function Expression

Function expression is another syntax for creating a function

let sayHi = function() {
 alert( "Hello" );                          <- Not global scope 
};

^This does the same thing as the function declaration method
I'm used to:  function sayHi() {
		 alert( "Hello" );             <- Global Scope
		} 

Note, a declared function has a global scope, expressed function doesn't. 

Because functions in Js are values, they can be copied
let variable = sayHi;

^Note sayHi doesn't have brackets, including the brackets makes 
the variable = the result of the function, this way the variable
equals the function. 

^Example, doing alert (sayHi) shows the function code, 
but alert (sayHi()) shows the alert within the function. 

Function expression requires the ; at the end; 

------------------------------------------------ Callback functions

A callback function is a function that's made to be a parameter in another 
function. 

ex: 

function ask(question, yes, no) {
	if (confirm(question)) yes()     <- your main function
	else no ();
	}

function showOk() {
	alert ("You Agreed.");
}

function showCancel() {
	alert( "You canceled.");
}

^Now we callback those two functions as parameters in main function

ask("Do you agree?", showOk, showCancel);

^Do you agree string is your question parameter, showOk function is called
as yes parameter, showCancel function is called as no parameter. 


A cleaner way to do the above is to declare the functions showOK and 
showCancel inside the ask() function call so that they only exist there.

ex:

function ask(question, yes, no){
	if (confirm(question)) yes()    <- same main function as before
	else no();
}

ask(
    "Do you agree?",
    function() { alert("you agreed."); },
    function() { alert("you canceled."); } 
   );

^ This declares the functions as the parameters, thus keeping them out 
of the rest of the code. This is a natural way to do things in Js. 

Strings and numbers represent data, functions represent actions. 

-------------------------------------Function Expression vs. Declaration

Declaration: function myFunction (parameter, parameter){code}

Expression: let variableName = function (parameter, parameter){code}

Expressions are created when the code execution reaches it and are only used 
then. 

Declarations can be used anywhere (if declared globally) in the script. 

In other words, you can use declared functions even if they're lower down
in the code. Declared functions are loaded before the script in Js. 

Expressed functions only work once the script reaches them. 

Remember that functions declared inside a block of code aren't global. 
But they can be used before the script reaches them as long as its inside
that same block of code.

If you want to use a function inside a block of code to work outside,
you need to define a variable by that function name and then use a function
expression inside the block of code.
example:

let age = prompt("What is your Age?", 18);

let welcome;                      <- declaring the variable globally

if (age < 18) {
       welcome = function() {                           <- assigning function
	 alert("Greetings Fellow Children!");              to expression
	};
} else {

	welcome = function() {
	alert("Greetings!");
	};
  }


Using function declaration is usually the way to go, but some circumstances 
are better suited for expressions (like case above). 

^ this way you can run the welcome() function outside of the block. 


----------------------------------- Arrow functions

syntax: 

let functionName = (parameter1,parameter2,etc,etc,) => expression

ex: let sum = (a, b) => a + b; 

If there's only one parameter, brackets can be omitted

ex: let double = n => n * 2;

Arrow functions can be used in the same way as function expressions like this:

() => alert("Hello")

Arrow functions that take up more than one line should use {}

ex: let sum = (a, b) => {
      let result = a + b;
      return result;
}; 


--------------------------------------------------For Loops

Common loop structure: 



for (let i = 0; i <= answer<varible already declared>; i++) {
}

^declares variable i

i <== answer; is the condition, it keeps going until i is greater than answer

i++  increases value of i by 1 with every iteration of the loop


-------------------------------------  Arrays 

An array is an ordered collection of data (strings, numbers, other types, etc)

To access a value in an array you use an index number. 

Syntax: let array_name = [ item1, item2, item3, etc];

^ you can use multiple lines if that reads better

alternate syntax: let name new Array(item1, item2, etc);

Use main syntax. let arrayName = [];

To make a variable out of an element in an array:

let newVariable = arrayName[#]   <- where # is the number of the element you
				   want in the list [0,1,2,3,etc]

^remember Index numbers start with [0]

To change an array element after you made it, syntax is:

arrayName[#] = "newElementName";      <- again # is the number of element

You can have functions and other arrays inside arrays?!


arrayName.length;  <- returns # of items (starting from 1)

To reference a varying number of parameters, use ( ... <name>) 
then use <name> to reference all of the arguments after the elipses. 

To add an element to an existing array: 
	arrayName.push("elementName");

 ^OR 

arrayName[arrayName.length] = "newElement";


To remove the last item from an array:
	arrayName.pop(); 

To sort an array alphabetically:
	arrayName.sort();


To make a string out of an array:
	let newVariable = arrayName.join(" ")

^The " " adds spaces between the array elements. 


To remove the last item from an array:
	arrayName.pop();

To remove the first item from an array:
	arrayName.shift();

To remove a specific item from an array:
	arrayName.splice(#,1)         <- # is the index num of item to remove

(remember when making a variable that splice will return the item spliced)

To add an item to the end of an array:
	arrayName.push();

To add an item to the start of an array:
	arrayName.unshift();

To add an item to a specific part of an array:
       arrayName.splice(x,y,newitem,newitem,etc) <- x = index position for 
							new items
						  y = # of items to remove
							(usually 0)

To create a new array that merges multiple arrays:
	let newArray = arrayOne.concat(arrayTwo, arrayThree, etc); 



arrayName.slice(x,y)  creates a new array out of items from x to just before y.

To make a copy of an array that isn't impacted by changes to the original:
const copyArray = [...originalArray]




Js does not support arrays with named indexes (some languages do)


----------------------------------- LOOPLOOPSURU

LOOP RUNS AS LONG AS 2ND STATEMENT REMAINS TRUE 

Common properties of loops:

Counter: Starting point of a loop

Condition: A true/false test to determine if loop keeps running,
it keeps running as long as its true. 

^^ AKA: LOOP RUNS UNTIL SECOND STATEMENT BECOMES FALSE

Iterator: Increments the counter until it satisfies the condition


For loop syntax:

	for (initializer; condition; final-expression) { //code }

The intitializer is usually a variable set to a number which is incremented 
when the loop runs. 

The condition is the stop point, usually a comparison (ex: i >= 100)

The final expression is run after every iteration, usually i++ or i--

The code runs with each iteration. 

example: 

	const cats = ['Bill', 'Jeff', 'Pete', 'Biggles', 'Jasmin'];
	let info = 'My cats are called ';
	
	for (let i = 0; i < cats.length; i++) {
  	info += cats[i] + ', ';
	}

^ The loop runs as long as i is less than the length of cats array (5)*
Every iteration adds 1 to i which makes info variable say the name of 
one more cat with a comma and space. Note that info is a string, so the 
+= is concat(heh)ing it 

*Note that since the last array index is 4, but the .length goes up to 5,
you want to make sure that i < cats.length and not i <= cats.length, since 
i is 0, and you don't want it i to equal 5 since the array index is 0-4. 


** Make sure not to use ===, since the first iteration is not equal to the 
end condition, so it wouldn't work at all. 

*** The above loop ends in a comma, to make it end in a period, nest an if
statement inside the loop so that

	 if i === cats.length - 1 { info += 'and' + cats[i] + "."
	} else {normal code}


To exit a loop before reaching the condition, add a break statement
(like the one used in switch). The example they give is in a conditional,
if condition is met do something then break the loop, else do something else
and continue looping.  


the continue statement works like break, but instead of exiting the loop
it skips to the next iteration without recording the current one if it 
doesn't meet a condition. 




-------------------While Loop

Syntax:

initializer            <- ex let i = 0;

while (condition) {               <- ex: i < 13501350
// code 

final-expression    <- after each iteration (ex. i++;) 
}



-------------- do while loop

Syntax:

initializer

do {
    // code to

    final-expression
} while (condition)

since the condition is after the loop, its always run at least once
while and for loops can not run once depending on condition.
 


Labels can be used to identify loops

syntax:

labelName:  <insert for loop here>

This is useful for break or continue statements in nested loops that will 
either break at or continue to the labeled loop. 

---------------------------------- Objects (Basics)-----------------------

Objects are created with curly brackets { } with an optional list of 
properties inside. Each property is set up with "key: value" where "key" is 
a string/property name, and the value is anything. 

Think of an object like a cabinet of files. Every data value is stored by a
key thats used to reference it. 

note that an object's contents can be changed even if the object is declared
with const. 


To make an empty object syntax:

let variable = new Object ();
or 
let variable = {} ;

^ The second way is more common. 

ex:   let user = {
	name: "John",
	age: 30 
	}; 

^This creates an object with two properties, one with a key of name with 
a value of "John", and one with a key of 'age' with a value of 30. 

Keys are converted into strings. ex: 0: "test" is same as "0": "test" 

To reference a property, do variable.key

ex: alert(user.name); <-returns 'John'


To add a property: variable.newKey = value; (ex: user.isAdmin = true;)
 
To remove a property use the delete operator:
ex: delete user.age; 

To use a multiword key, the whole key name has to be in "".

ex: "likes birds": true 


^to reference multiword key, use [] INSTEAD OF A PERIOD. 

ex: alert(user["likes birds"]);

ex2: user["likes birds"] = true; (to add it to the object)


Square brackets are also used with a key to reference its value.

ex: user["age"]; returns 30

Can also be used for variables outside of the object.
ex: let key = "likes birds"
user[key]; returns true 


^ This use of square brackets gives a lot of flexibility.

ex: let key = prompt("What do you want to know about the user?");
	if (prompt = "name") {
	alert(user[key]);}

^since "name" exists in the object, if key becomes "name", referencing it 
with the user object will give the "name" value. 

"computed properties" just seems like a fancy term for referencing a
variable that already exists by using [] in an object. 

ex: let fruit = "apple"
    let bag = {
	[fruit]: 5,
	};
^Without the []. you'd have the name fruit for the value of 5. But this way
you have apple (or whatever else that variable becomes) with the value of 5. 

Property value shorthand:

It's common to use existing variables as values for property names.
   
ex: function makeUser(name, age) {
	return {
	name: name,		<- makes it return an object
	age: age,
	};
	} 

^This is so common that theres a shorthand method to just write it once.

ex: function makeUser (name, age) {
	return {
	name,            <-- same as name: name, 
	age, 		<--- same as age: age, 
	pets: 3,         <---- can combine shorthand properties w/ regular
	}
	}; 


The special operator <in> can be used to see if a key exists in an object. 

ex: 
alert ( "1teigwhewgihw" in user);  returns false, because that key doesnt 
exist in user object. 

Alternatively, alert (user["eiangeapigna"]) would return as undefined, meaning
thats not in the object. 


To cycle through every key in an object, there's a special loop called 
for... in

syntax: for (key in objectName) { executes code for each key in object}

ex: for (let key in user) {     <- note key can be called anything
alert (key);  <-- alerts every key name
alert (user[key]) <---- alerts every value 
}; 


Note: keys in a loop will be referenced in ascending order if they're integer 
or strings made of integer (ex; "43"). But in order of creation if they arent
integer. 

to "cheat" and make integers appear in order of creation, just add a + to them

ex: "+43" will appear before "+31" if it was created first. 


Functions inside objects are called methods, can be accessed same way. 

ex: person.bio()    Where person is object name and bio () is function inside

object literal = term meaning an object that we create the content for while
making the object. 

you can make objects inside objects.

ex: const person = {
name: { 
first: 'Bob', 
last: 'Smith}, 
age: 32,} 

^ to access a nested object, just add another dot. person.name.first 
or person['name']['first']. 

can also create new keys and properties outside of the object

ex: let newDataName = 'height'
    let newDataValue = '1.5m' 

person[newDataName] = [newDataValue]     <- Now, person[height] = [1.5m]

--------------- this -----------------

the this keyword refers to the current object the code is being written in.

Very useful when dynamically generating objects. (more on this later) 




-----------------Arrays (Continued) -----------------

To filter array contents: 

let filterVariable = arrayName.filter(function(parameter) {
  if (parameter.propertyName > 100) {return true;}  <- return true means keep
		
}) 

^ The filter method loops through the array automatically, so the parameter 
refers to each item in the array. So this example checks each parameter's 
property value, and if its more than 100 it gets included in the
filtered array. 

Array Map method:

The array.map will create a new array the same length as the original array.

ex: exArray has 8 objects each w/ first name, last name, and age properties

^ const fullNames = exArray.map(function (parameter) {
		return parameter.firstName + '' + parameter.lastName)	
		}

This creates a new Array with a length of 8 (same as og array), where each
item is a concat of first and last name (so again, parameter = each object
in the original array). Remember to specify return value if not using arrowF

Array sort:

Sort works by comparing two items based on a property, and then assigning 
1 to the item you want on top, and -1 to item on bottom.

ex: const newArray = oldArray.sort(function (a,b){
                     if (a.property > b.property){
			return 1}
			else {return -1} 

^In this case, we want to sort by ascending order, so a > b returns 1, the 
greater property is assigned a higher index value. 


How sort works:
if a.property > b.property returns a negative number AND b > a returns a positive, 
a is lower index value and appears first. 

I think just one comparison where b > a returns 1 will list in descending
order. 



Array Reduce : 

arrayName.reduce( function (total, amount, index*, array*){} );

*optional

total: the initial value, or previously returned value of the function
amount: aka current value, the value of the current element 


Reduce cycles through each amount in array like in a for loop, 
at the start of the loop the default total value is the first array value
and the current amount is the next array value. Each time the current value
changes to the next number in the array. When no more numbers are left,
 it returns total value. 
Index refers to the number of times the reduce has looped over
the array. 

example if you wanted to find the average amount of an array:

const average = moneyArray.reduce(function (total, amount, index, array)
{ total+= amount;
 if (index === array.length -1) {
 return total/array.lnegth;
} else {
return total;
} 
}); 

^ This makes total equal to all the amounts, and if the loops has iterated
each time, return the total divided by the number of array elements. 

Reduce is incredibly powerful. It will repeat whatever logic for each amount
in the array and then return a single value or even a new array. 


Important**: To set an initial value, place a comma after the {} code 
and type the value before closing the brackets on the reduce method. If the total is 
not specified like this, it will default to the first amount in the array.

A very helpful thing is to use an empty array as your initial value, and then
pass the code into that new array. This is identical to the map function, but 
the benefit of doing it in reduce is that you can filter it first using an if 
statement and then map the filtered results to a new array. 

^TLDR: you can combine filter and map with reduce. 


You can use reduce to find the amount of times you have each value in an array.

ex:

const count = arrayName.reduce ( function (tally, value) {
 tally[value] = (tally[value] || 0) + 1; 
 return tally; 
}, {})  

^Initial value must be an empty object. 

The initial value is an empty object, and it goes through each element, 
it checks to see if the total contains a key with the current value of the
reducer. If no, it creates it, if yes it adds +1. I think. 


Common mistakes w/ reduce: Make sure to set an initial value unless you're 
just adding array values. Make sure to specify a return value. 


To make an array out of a nodelist: 

const newArrat = Array.from(nodelist); 

^ ex: const links = Array.from(category.querySelectorAll('a'));



array.some(): 

.some checks to see if there's at least one thing in your array that matches what you're looking for.

ex: const ageCheck = arrayName.some(function (parameter)) {
if (parameter.age >= 18) {return true;}

^basic example that checks to see if any element has an age of at least 18. 

array.every():

Works same as array.some but requires all to meet condition, just replace some() with every(). 



array.find():

Similar to filter, but it only returns the first one that meets the criteria. 

ex if trying to find a comment from an array of objects based on its id #: 

const idFind = comments.find(function (text)
{text.id = 823423; 
return true;
})

^ This returns the object with the matching ID property. 


array.findIndex():

array.findIndex() finds the index number of the specific item. syntax is same as .find 


To "wrap around" an array:

//Given x, an integer >= 0, we can securely get a valid index in our
// 5-element array in terms of x using this formula:
//current index = x % array size

^^This way, we guarantee that x will be in [0 - 4] since the size is 5.

^Example in caesar exercise: x = alphabetLower[alphabetLower.indexOf(array[i]) + shift] % alphabetLower.length

Let's say our starting value is [11] (L) and our shift is 75. 86 % 26 = [8] (I)

^For negative shifts, add the array length to the final number. 
		

To add a key and a value to an object within an array of objects:

array.filter( paramter => {
if (!parameter.missingkey) {
return parameter.missingkey = 'value'
}

^ This adds the missing key to the array object(s) missing it and assigns it that value. :) 
