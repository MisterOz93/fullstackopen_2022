in this doc: **** seperates topics, >>>> is related sidenote.

r15 pw for db (r***15) <- diff from login to atlas

$npm install mongoose 

Note: according to fso mongoose documentation isnt very good w/ styling,
best to avoid copy/paste from it.

*********************************
***writing to db with js***:

$node fileName.js {db password}

^for this to work, in the code you need to set
const password = process.argv[2]
and then const url=`mongodb+srv://MisterOz93:${password}@cluster0.vediu.mongodb.net/noteApp?retryWrites=true&w=majority`
(the exact url is on the atlas website under 'connect' to app)

^change the string btwn .net/ and the first ? for the name of the collection.

after setting url:
mongoose.connect(url).then((result) => {

	const foo = new Foo( {...}) //using a Foo model defined elsewhere
	return foo.save()//can chain save() w/ then()
}).then(() => { mongoose.connection.close()}).catch(e => clog(e))

^^ assuming that there's a model for a Foo object in the doc or elsewhere.

************************************
Model/Schema:

first define the schema, ex:
const fooSchema = new mongoose.Schema({
	key: Type,
	key2: Type,
	etc. 
})

schemas tell mongoose how Foo objects are to be stored in db.
Models are basically constructors. 

Schemas can also be used to validate.
^ex (inside a Schema definition):

fieldname: {
   type: String, 
   minLength: 42,
   required: true
}, 

mongoose has built in validators (minlength/required/etc.) but you can 
make custom as well.

IMPORTANT: by default, validators arent run with findOneAndUpdate method.
To override this, in the 3rd parameter that has {new: true}, change it to:
{new: true, runValidator: true, context: 'query'}

second define the model: 
const Foo = mongoose.model('Foo', fooSchema)
^the first arg is singular name of model, mongoose convention
is to automatically name collections as lowercased plural.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
schemas should be defined in models dir that export the model.
ex:
in root/models/foo.js:

const mongoose = require('mongoose')
const url = process.env.MONGODB_URI
mongoose.connect(url)

const fooSchema = new fooSchema({...})

fooSchema.set('toJSON', {....}) //see formatting objects below

module.exports = mongoose.model('Foo', fooSchema)

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
From FSO: 

" Document databases like Mongo are schemaless, meaning that the 
database itself does not care about the structure of the data that 
is stored in the database. It is possible to store documents with 
completely different fields in the same collection.

The idea behind Mongoose is that the data stored in the database 
is given a schema at the level of the application that defines 
the shape of the documents stored in any given collection. "

*************************** 
Fetching from db:

Foo.find({}).then(res => {
  res.forEach(foo => {
	clog(foo)})
  mongoose.collection.close() //note that close happens at the end of callbk)
})

^the parameter for the find method is an object expressing search conditions.
ex could be: Foo.find({important: true}).then(...)

***************************
Formatting the Objects returned by Mongoose:

One way to do it is modifying the 'toJSON' method for 
each schema.
ex:
  fooSchema.set('toJSON. {
    transform: (document, returnedObject) => {
	returnedObject.id = returnedObject._id.toString()
	delete returnedObject._id
	delete returnedObject.__v
	}
     })
^changes the _id field to a string id and removes the __v field.
*******************************

Adding an entry to the DB:

inside the app's post route:

first save request.body, then create new object using
the model's constructor function(ex: const foo = new Foo({...})
then:
foo.save().then(savedFoo => response.json(savedFoo))

^response there is from the post method's callback
putting it inside save() callback ensures its only sent
if operation succeeds.
********************************

Fetching an individual entry from the DB:

app.get('/api/foos/:id, (req, res) => {
  Foo.findById(req.params.id).then(foo => {
	if (foo){
	 res.json(foo)}
	else {
	  res.status(404).end()
	}
      }) 

Fetching all entries:
app.get('/api/foos', (req,res) => {
  Foo.find({}).then(foos => response.json(foos)})

*******************************
Deleting from db:

ex:

app.delete('/api/foos/:id', (req, res, next) => {
  Foo.findByIdAndRemove(req.params.id).then(result => {
	res.status(204).end()
   }).catch(error => next(error))
})

^note: result callback could be used to check if delete actually worked.

*********************************
Updating from db:
ex:

app.put('/api/foos/:id', (req, res, next) => {
  const body = req.body
  const foo = {
     datafield: body.datafield
     .....
   }
  Foo.findByIdAndUpdate(req.params.id, foo, 
    {new: true, runValidator: true, context: 'query'})
  .then(updatedFoo => {
     res.json(updatedFoo)
    })
    .catch(error => next(error))
   })

^note the findByIdAndUpdate method takes a js object and
not a model constructor (the foo created higher up)
also note the optional 3rd parameter. Setting it to 
{new: true} calls the event handler w/ the modified document
instead of the original. 
********************************

Creating a relationship between collections (ie: User & Note):

One way to do it is create a reference key in the Note 
object by adding a property user
with the value equal to the ID of the User who created it. 
Or have a notes field in the User object with an array of 
IDs of the notes that they created. Or both.

Ex in User: {username: 'foo',
	     _id: 123456,
	     notes: [22122, 22123]
	     }
 in Note: 
	{ content: 'bar',
	  _id: 22122,
          user: 123456
        }
^notice how the user's _id is referenced in Note and vice versa.
There's no *best* way to do it, it depends on design decisions made
based on expected use cases of application.


In the User Schema, define notes property as:

notes: [ 
	{ 
	   type: mongoose.Schema.Types.ObjectId,
	   ref: 'Note'
         }
The type is ObjectId, which references note-style documents. 

In the Notes Schema, user is defined as:

   user: {
           type: mongoose.Schema.Types.ObjectId,
	   ref: 'User'
	}


