To link an external CSS sheet to html doc use <link> in html head:

<link href="main.css" rel="stylesheet">

with href being the css document, and rel being relationship to show
how the item is being linked to the html.



-Apart from the selector, each ruleset must be wrapped in curly braces. ({})

-Within each declaration, you must use a colon (:) 
to separate the property from its value or values.

-Within each ruleset, you must use a semicolon (;) 
to separate each declaration from the next one.

-Anything in CSS  between /* and */ is a CSS comment. 
The browser ignores comments as it renders the code. 
CSS comments are a way for you to write helpful notes about your code or logic.

class = reusable styles ex: <style> .blue-text { color: blue; } </style>

^ .blue-text is the class, and can be applied in an HTML element with: 
class ="blue-text" (No starting period in the HTML element)

Periods are used to mark class, # used to mark id. 

pseudo class = added to selectors to only do something when in a specific state
(ex: item:hover { color: blue ; } <- this makes the item element turn blue when 
cursor hovers over it. 

Bigger margin = smaller box

When applying conflicting classes to an element, the last one listed takes priority
ex: class="pink-text blue-text"> text will be blue. !important in style takes ultimate precedence.

:root selector is useful to store variables so they can be applied
to any part of the document.

Syntax for setting a variable: --variablename: value;

<strong> = bold, <em> = italics, <u> = underline, <s> = strikethrough, 
<hr> (self closing)= horizontal line

z-index: = used to determine layer positioning
hsl (0,0%,0%) = hue, saturation, lightness

background: linear-gradient([x]deg, color 1, color2) <- makes nice gradient background

transform: very handy property, can modify an element in many ways, 
can pair w/ pseudo-class (ex with :hover to make it scale when hovered over)

#anim = how animations behave 
(ex: animation-name:, animation-duration:, animation-iteration-count:, 
animation-timing-funcion:,)
@keyframes = controls what happens during animation 
(uses % to reference frames of "movie") 
cubic-bezier = used in animation-timing-function: shape of an animation's curve

media queries = change presentation based on device being used
ex: @media (max-width: 100px) { /* CSS Rules */ }

to make an img responsive: 
img {
  max-width: 100%;
  height: auto;
}

to make your images properly appear on
 High-Resolution Displays is 
to define their width and height values as only half of original file. 

can use vh/vw/vmin/vmax (min/max refer to smaller/bigger btwn w and h)
for size based on % of viewport instead of px. 
ex: body { width: 30vw; }
------------------------------------------------ Flexbox
display: flex ; <- lets you use flex-direction for the selector. (movement stuff)
ex: flex-direction: row | row-reverse | column | column-reverse 


Main axis = Y Axis if flex box items are in a column
Main axis = X Axis if flex is a row 
Cross axis = The non-main axis. 

justify-content: used for main axis, align-items: used for cross axis.

flex-wrap: wrap; = pushes some content to next line
flex-shrink: [number] = put in flex items (not main container)
^also flex-grow:
flex-basis: = sets the basis for flex changes (this uses px/em/%)

^ can do all 3 with flex: (grow#shrink#basis#)

order: = assign number value to reorder the flex items.

align-self: = lets you adjust alignment individually (same commands as align-items (ex flex-end, center) 

----------------------------------------------- Grid

display: grid; <-turns the element into a grid
grid-template-columns: 100px 100px 100px; <- gives grid columns(3 in this case)
^ grid-template-rows: <- same as columns (px/%/fr/auto to adjust size)
can use grid-template-columns: repeat(x,ypx) <- x= # of columns 
^or repeat(x,y,z,)t Where y and z alternate x times and you end with t.
repeat(auto-fill, *px) <- inserts as many rows or columns as possible. [HANDY] 
repeat(auto-fit, *px) <- similar to auto-fill, but stretches items instead of adds?
minmax(*px,*px); <- limits size of items when grid changes size.
grid-gap: <- gives gap for both col/row if 1 value, row then col if 2 values.

^these all are for grid containers (the parent)

grid-column: x/y ; <- makes the item start at x and go to y (ex: 3 by 3 grid)
grid-row: ^same, basically, higher amnt btwn x and y makes it take up more space
justify-self:  <- positions the item horizontally
align-self: <- positions item vertically (takes values like, start/center/end)
justify-items/align-items: <- does the above to all items (so put it in the container)

Can group cells of grid together into an area and give area a name with
grid-template-areas: "nameofcell1 nameofcell2 nameofcell3"
		     "nameofcell4 nameofcell5 nameofcell6"
		      "nameofcell7 nameofcell8 nameofcell9"
Cells w/ same name form an area.^ Use a period(.) to designate an empty cell.
grid-area: areaname ; <- puts item in that area

if no area names, can still use grid-area: x/y/z/t; (x=horiz start, y=vert start, z=horiz end, t=vert end


Can create grids within a grid by doing display: grid; for items in a grid. 

^note: modifying a grid only affects the direct descendant. 

margin: auto ; <- centers element. 