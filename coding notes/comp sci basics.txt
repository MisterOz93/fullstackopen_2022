**ctl f for chess when the time comes


---------Recursion-----------


2 Key principles: the end goal (known as base case)
		 the process that gets broken down



----Merge Sort Algorithm---

The idea is to sort smaller arrays, then combine the arrays together
in sorted order, using recursion. 

In pseudocode: Sort the left half of the data 
		then sort the right half, 
		then merge the two halves together. 

The base case is a single element array

^Merge sort ruby pseudocode example:

def merge_sort(arr)

	if arr.length < 2
		return arr    #explicit return important
	end
	split arr into first half and second half
	call merge function(merge_sort(first_half), merge_sort(second_half) 
	#note merge function isn't a thing yet, recursively calling merge_sort 
	#on each parameter will ensure they get broken down into 2s 
	
	end 
end

def merge(first,second)
	merged_array = []
	while first[0] && second[0]
	   push the smaller element into merged_array and shift that array
	end
	return merged_array.concat(first).concat(second)
	#^ since the loop ends with one exhausted array, concating them both
	#will just put in whatever is leftover from the larger array.
end 


------------------------ Data Structures ------------

The basic idea of a data structure is to store data in a way that 
meets the needs of your particular application. 
The differences between them typically have to do with trade-offs between how long 
it takes to first populate the structure, how long it takes to add or
find elements, and how large the structure is in memory.






--------------------Binary Search-------------

Trying to find a specific number by dividing the data in half, discarding the
half that the number is not in. (ex: phonebook from CS50) 
^^^Only works with a sorted array. 


Pseudocode (assuming array is sorted, sort it if not):

Repeat until subarray is size 0 (0 ensures it doesnt look forever for a missing value):

Calculate middle point of current subarray

if target is at the middle, stop

else, if target is less than middle, repeat, changing the end point to be
just before where the middle was. (aka: my new end point is the last element of the
half where my target is)
else, repeat, changing the start point to just after the middle (aka: new start point
is first element of the half where my target is) 


ex: [6,7,8,9,10,11,14,15,17,19,22,23,25,28,30] (15 element array
target is 19[at index 9]

step 1: find midpoint (0 + 14 / 2) [7], which is 15 
step 2: since 19 > 15, discard everything up to and including 15, [8] is new start
step 3: calculate new mid point(8 + 14 / 2) [11], which is 23
step 4: since 19 < 23, discard 23 and everything after it. [10] is new end
step 5: calculate new mid point (8 + 10 /2) [9], which is 19. return array[9]

------------------------Binary Search Tree--------------------

A hierarchy based data structure. 
Bigger/equal numbers go to the right of the parent node
smaller to the left, max 2 childs per node.

ex: using array [5,7,1,15,9,2,14,8,7,3]
The tree goes in index order:

	5     <- root node
      1    7   
       2      15 
        3     9
 	    8  14  	
	   7

^A bit hard to visualize without arrows, 
but just remember to go through the array index
moving an element to the right if its equal or greater
and to the left if its less than.

So 7 goes to the bottom right of 5, 1 to the bottom 
left. Since 5 has two child nodes now, new elements are
now children of 1 and 7. 15 becomes right child of 7
9 becomes right child of 15, 2 right child of 1, 
14 right child of 9, 7 left child of 9, 7 left child
of 8, 3 right child of 2. 



------------Stacks and Queues-----------

Core concepts used in BFS/DFS (discussed below)

Stacks: Add/remove from the top (pushing elements 
to the top, popping from the top) Last in first out.
This is how recursion works. 

No index, can only add/remove from the top.
Most useful when you want to reverse the order of elements
ex: undo button in word pops from the top of the stack.


Queues: A single file line. Font/Back. Add elements
from the back, remove from the front. FIFO

Adding: Enqueue, Removing: Dequeue. 

Useful when managing resources. 
ex: printer queue, first request gets printed first. 

used a queue in BFS by using recursion, using queue[0] as 
parameter after removing the 1st item and reading it. 


-------------------Tree traversal(BFS/DFS)--------------

An algorithm for visiting each node in a tree (like
the binary search tree above) exactly one time.

Two categories of graph traversal 
(tree is a type of graph):

Breadth-First & Depth First searches.

****Breadth first:**** visit all nodes at the same level 
from left to right before moving down to the next level.

ex:    7         <- root at level 0
     1   9   <- level 1
      2 8  11  <- level 2 

So I start at 7, then visit 1, then 9, then 2, then 8
then 11.       


Breadth first is also known as level order. 

Algorithm for breadth first:
 
If root is null, return
Else create a queue (FIFO). 
Step 1: Enqueue the root node's address(reference) in the queue. 
Step 2: If queue is not empty, take out the front node, read it, then enqueue its children.
(left child then right child). 

Ex:   7
    1   9
     2  8 11

Queue goes like: |7|
then |1,9|, then |9,2|, then |2,8,11| 
 



***Depth First:*** Visit all grandchildren on one half of the
tree. Then visit all grandchildren on the other half.

Hint: This is really good for games like chess where each move is like a 
branch on the tree. Might be a way to implement AI? 

ex:   7
    1    9
     2  8  11

After 7, can go down the left side and visit 1 and 2, 
or go down the right side and visit 9 8 and 11. 

3 popular depth-first strategies using recursion:

1) Preorder traversal: 
visit the root, then left, then right. (subtrees visited recursively
remember once you visit a child, it can be considered the new root 
in recursion)

2) Inorder traversal:
visit the left, then root, then right

3)Postorder traversal:
visit left, then right, then root. 

To keep your strategy clear, consider D(ata) L(eft) R(ight)

Ex: Preorder traversal for each node you go DLR. 
  step 1: Read Data
  step 2: if Left, go Left (return to step 1 w/ Left as new Data)
  step 3: if Right, go Right (return to step 1 w/ Right as new Data) 

    Inorder you go LDR for each node
    Post for each node you go LRD 

ex: Inorder traversal (LDR)
	step 1: If Left, go left (repeat this step with Left as new root)
	step 2: Read data
	step 3: If right, go right


^^Inorder traversal of a binary search tree gives you a sorted list.

ex: Postorder traversal (LRD)

Step 1: If left, go left (repeat with Left as new root)
Step 2: If right, go right (Repeat with Right as new root)
Step 3: Read data

^ original root is the last data read. 



-----------------------------Linked List---------------


Similar to array, but elements can be inserted/removed without
having to move the other elements. 

(in ruby, arrays can be big enough where linked lists are useless,
but still worth learning for fundamentals). 


A linked list is a linear collection of data elements called nodes 
that “point” to the next node by means of a pointer.

Each node holds a single element of data and a link or pointer to the 
next node in the list.

A head node is the first node in the list, 
a tail node is the last node in the list. Below is a basic representation of a linked list:

[ NODE(head) ] -> [ NODE ] -> [ NODE(tail) ] -> nil

To search through the list, you start at the head element, and follow
pointers. To add a node, you change the pointers so that the node before
the new data points to it, and the new data points to the node after it.
If a new node is added to the end, that node points to null.  

Ex: 11 -> 13 -> nil 

If you want to add 12, change 11's pointer to 12, and 12's pointer 
points to 13. 


------------------Graph---------------


data structure where different two verticies are connected by an edge (a line). 
an edge connecting vertex a with vertex b would be denoted as (a,b) or (b,a)
if the graph is 'undirected' (aka the verticies point to each other)
verticies connected are 'neighbours' and the edge is 'incident' on the two
verticies. the number of edges incident on a vertex is the 'degree' of a vertex

when a vertex goes on a path from a particular vertex back to itself, thats a
'cycle'. 
edges can have numeric values, whic his known as its 'weight' on a 'weighted graph'

a graph with no cycles (impossible to get back) is a 'directed acylic graph (dag)


Representing a graph: 3 main ways (edge list, adjacency matrix, adjacency list)


Edge lists: 

The easiest way to represent a graph is an array with every edge.
or an array of objects that contain vertex number of each? 

edges are represented with an array of the two verticies

ex: [ [0,1], [0,3], [3,4],etc etc] 

if edges are weighted, can add a 3rd number to each array or more information
to the object.

Downside to edge list is that finding if an edge exists is a linear search.


Adjacency Matricies: 

create an 'adjacency matrix' that is v rows by v columns large (v = # of verticies)
full of 0s, and then set the value 1 if the corresponding verticies have an edge.

ex:    0001
       0010	 <- [0,3] and [1,2] are edges. 
       0100
       1000 
	In javascript for example, the matrix can be created using a nested array.
	[[0,0,0,1], [0,0,1,0], etc]

Adjacency Lists: 

A combination of edge lists and adjacency matrix. 
For each vertex, store an array of the verticies adjacent (connected) to it.

ex:  [ [1,6,8],   <- verticies connected to vertex 0 
	[0,4,6,9],
	etc. etc. ]

You can use a for-loop to iterate through the vertices in an adjacency list


For example, suppose that you have an adjacency-list representation of a graph
in the variable *graph*, so that *graph*[i] is an array containing 
the neighbors of vertex i. Then, to call a function doStuff on 
each vertex adjacent to vertex i, you could use the following 
JavaScript code:

for (var j = 0; j < graph[i].length; j++) {  
    doStuff(graph[i][j]);
}

^- graph[i] is an array of i's neighbors