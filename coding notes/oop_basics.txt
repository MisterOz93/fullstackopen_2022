

--------------Fundamentals of OOP-------

Encapsulation: Protecting/hiding data and pieces of functionality to stop data from being changed without obvious intention.

Polymorphism: The ability for different objects to use the same methods. 

Inheritence: sub classes inheriting methods from a super class. 

Instantiation: the process of creating a new object or instance from a class (ex: variable = Class.New)

Modules are used to mix in methods/constants to multiple objects.

Instance  methods are behaviours shared by objects of teh same class.

A getter method is what we create inside a class to return the name of an instance variable.
ex:  def get_name
	@name
      end 
 ^can then call the method outside the class to get the object's name. 

A setter method is used to change the name of an instance variable. 
ex (again inside the class):  def set_name=(name)
				 @name = name
			      end 
^then outside the class, can change by doing object.set_name = x 

*Ruby convention is to name getter <name> and setter <name=(n)>  

Note that getter/setter are used in ruby as acessors (attr_accessor :name)

With getter/setter set, reference the instance method instead of the instance variable
within code ex: "#{name}" instead of "#{@name}". 
^This will save a lot of headaches. 

self. <- a prefix for accessor and instance methods to max ruby know we arent creating local variables
(sometimes it can make that mistake when not using @, I'm not 100% clear on reason).




---------Classes-----

A class is a way of organizing objects that have similar attributes and methods.
ex: String is a class. 

Ruby class syntax: class ClassName    <- classes are named CapitalCamelCase
		  #codestuff
		end 

initialize: the **constructor** that "boots up" each object created in the class. 
def initialize within the class. When creating a new object in the class, use the same parameters
that initialize takes. 

After initialize, what you define are methods to use with the instances of the class
you create. 

IN RUBY: you use @ before a variable name to signify that it is an 
"Instance variable" which means it belongs to the instance of the class. create
these variables within initialize function. 

^ex: @name = name <- this tells ruby that whenever you create a new object in the 
class, it has to have a name, and each object in the class will have its own name 



Use @@ before a **class variable**, a variable that applies to the whole class.
So the instance variable is different for each instance, the class variable isn't?
ex: you can define a class variable, and then increment it in an instance 
variable. So that it counts the number of instances of the class you create.
You can also create an empty hash a class variable, then make instance variables 
to add key/values to it based on parameters. (ex: @@hash[key] =value) 


put a $ at the start of a variable inside a method or class to make it global.
Be sure to use the $ to call it. 

^note, global variables arent recommended, better to stick with instance and
class vars.

Can create class methods to interact with class variables (@@)
create a class method in Ruby within the class (outside initialize):

def self.method_name   (or the class name instead of self)
 
Class methods can be called without creating (instantiating) an object.

self refers to the class when used in a *definition*, but refers to 
an object when used *inside* a method. 


ex: def self.total_number_of_objects   <---- this self refers to the class

^ex: def weight(lbs)
	self.weight = lbs     <- this  self refers to an object 






--------------------------Inheritance---------
The process of one class taking on the attributes and methods of another. 

IN RUBY, inheritance syntax is: NewClass < EstablishedClass
^ NewClass inherits from EstablishedClass (lingo is: New_class extends established_class)

You can redefine an inherited method so that it works a different way for the
new class. 


In the new class that inherited, you can still call the original method using
the keyword <super> inside of the altered method. super takes parameters if
the original method does as well.

It's common to use super(with parameters) inside the child's initialize to copy the parent but
add some distinctions. 

Every class in Ruby can only have one super class. Some languages can have
classes with multiple parents (multiple inheritence). 



-------------------------Interface/Implementation--------------
Default thinking should be to hide as much as possible from the user.


Can define methods as public (Interface) or private (Implentation) <- public / private are Ruby syntax 
Public is default, private methods are not accessible unless you acces w/ public methods that know how to access it. 
Everything below the keyword is set to that until the end of 
the class definition or until specified. 

There's also protected. protected gives most of private's privacy, but it lets other methods inside the same instance/class
or children accesses it as well.


---------------------accessors----------------

attr_reader and attr_writer to access and edit variables. Kind of confusing, but here's whats happening:

attr_writer :age  is the same as: 

		def age=(value)
		@age = value
		   end

attr_reader :age is the same as:

	def age
	@age
	end 

attr_accessor does both.

I think this boils down to what people can do with certain variables, but im not sure. keep reading :) 


-------------Module-----------
Modules are similar to classes, but instead of having instances/subclasses, they 
just store methods and constants*. Think of them as toolboxes. 
*Constants are ALL_CAPS in Ruby
Syntax is module ModuleName

One of module main purposes is namespacing.

Namespacing: seperating methods and constants into named spaces.Using 
the scope resolution operator (x::y) this tells ruby to use the x module's y

Most modules must be 'required' in order to work. type require 'ModuleName'(as a string)

you can also <include> a module inside a class so that the class has 
access to the module's methods. 


-------Mixin---------

A mixin is a class that has a module included. 

include is used to include a module's methods at the instance level. 

extend is used to add a module's methods at the class level. 


-------------------------
use ancestors method on any class to display the path ruby takes to retreive the method. 
because puts uses the default to_s method, creating a to_s method that prints a relevant string is good way 
for puts to show the object in a readable way. 


methods should not reach outside its scope to modify variables unless that is its specific purpose. 
methods should take an input and give a return without modifying variables unless they must. 